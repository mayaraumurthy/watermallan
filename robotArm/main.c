#pragma config(Motor,  motorA,          Arm1,          tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          Arm2,          tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "robotArm2.c"
#include "waveFrontDir2.c"
#include "results.c"

float XA = 3.75;
float YA = 2.5;

float XB;
float YB;

float goalDeg1;
float goalDeg2;

float goalCol;
float goalRow;

float startRow = 9;
float startCol = 0;


path pathArray;

void calcPath(){
	goalCol = fromDegreesToBox(goalDeg1);
	goalRow = fromDegreesToBox(goalDeg2 );
	calcPath(&pathArray, goalRow, goalCol, startRow, startCol);
	if(pathArray.validPath) return;

	goalCol = fromDegreesToBox(goalDeg1 - 20);
	goalRow = fromDegreesToBox(goalDeg2 );
	calcPath(&pathArray, goalRow, goalCol, startRow, startCol);
	if(pathArray.validPath) return;

	goalCol = fromDegreesToBox(goalDeg1 + 20);
	goalRow = fromDegreesToBox(goalDeg2 );
	calcPath(&pathArray, goalRow, goalCol, startRow, startCol);
	if(pathArray.validPath) return;

	goalCol = fromDegreesToBox(goalDeg1);
	goalRow = fromDegreesToBox(goalDeg2 - 20 );
	calcPath(&pathArray, goalRow, goalCol, startRow, startCol);
	if(pathArray.validPath) return;


	goalCol = fromDegreesToBox(goalDeg1);
	goalRow = fromDegreesToBox(goalDeg2 + 20 );
	calcPath(&pathArray, goalRow, goalCol, startRow, startCol);
	if(pathArray.validPath) return;
}

void findTheta(float X, float Y){
	initializeThing();

	float goalRad2 = (getGoalDegree2(X, Y, false);
	float goalRad1 = getGoalDegree1(X, Y, goalRad2);

	goalDeg1 = radiansToDegrees(goalRad1);
	goalDeg2 = radiansToDegrees(goalRad2);

	if(goalDeg1 >= 0 && goalDeg1 <= 180){
		if(goalDeg2 < Meena.matrix[goalDeg1][0] || goalDeg2 > Meena.matrix[goalDeg1][0]) return;
	}

	goalRad2 = (getGoalDegree2(X, Y, true);
	goalRad1 = getGoalDegree1(X, Y, goalRad2);

	goalDeg1 = radiansToDegrees(goalRad1);
	goalDeg2 = radiansToDegrees(goalRad2);

	if(goalDeg1 >= 0 && goalDeg1 <= 180){
		if(goalDeg2 < Meena.matrix[goalDeg1][0] || goalDeg2 > Meena.matrix[goalDeg1][0]) return;
	}

}

void goToTarget(float X, float Y)
{
	////    SETUP //////////////////////////////////

	//CHANGE THIS TO CHECK WHETHER THESE ARE VALID
	findTheta(X, Y);
	//CHANGE THIS TO CHECK WHETHER THESE ARE VALID

	calcPath();

	///////////// END SETUP///////////////////////////

	int i = 1;
	while( i < pathArray.pathLength){
		int theta1 = fromBoxToDegrees(pathArray.waypoints[i].c);
		int theta2 = fromBoxToDegrees(pathArray.waypoints[i].r);
		goToDegree(theta1, theta2);
		i = i + 1;
	}

	goToExactGoal(goalDeg1, goalDeg2);

	startRow = goalRow;
	startCol = goalCol;
}



task main{

	goToTarget(XA, YA);
}
