<html><head><title>robotArmWebsite</title><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol.lst-kix_8uacmh1uuah1-6.start{counter-reset:lst-ctn-kix_8uacmh1uuah1-6 0}ol.lst-kix_5dgjavd71mnf-3.start{counter-reset:lst-ctn-kix_5dgjavd71mnf-3 0}ol.lst-kix_5dgjavd71mnf-1.start{counter-reset:lst-ctn-kix_5dgjavd71mnf-1 0}.lst-kix_xd5kyx5b2yqr-3>li{counter-increment:lst-ctn-kix_xd5kyx5b2yqr-3}ol.lst-kix_mwk8aq9dzms2-2{list-style-type:none}ol.lst-kix_mwk8aq9dzms2-1{list-style-type:none}ol.lst-kix_mwk8aq9dzms2-6.start{counter-reset:lst-ctn-kix_mwk8aq9dzms2-6 0}ol.lst-kix_mwk8aq9dzms2-0{list-style-type:none}ol.lst-kix_mwk8aq9dzms2-0.start{counter-reset:lst-ctn-kix_mwk8aq9dzms2-0 0}ol.lst-kix_8uacmh1uuah1-8.start{counter-reset:lst-ctn-kix_8uacmh1uuah1-8 0}ol.lst-kix_xd5kyx5b2yqr-1.start{counter-reset:lst-ctn-kix_xd5kyx5b2yqr-1 0}.lst-kix_8uacmh1uuah1-0>li:before{content:"" counter(lst-ctn-kix_8uacmh1uuah1-0,upper-latin) ". "}ol.lst-kix_mwk8aq9dzms2-5.start{counter-reset:lst-ctn-kix_mwk8aq9dzms2-5 0}.lst-kix_xd5kyx5b2yqr-1>li:before{content:"" counter(lst-ctn-kix_xd5kyx5b2yqr-1,lower-roman) ". "}ol.lst-kix_5dgjavd71mnf-0.start{counter-reset:lst-ctn-kix_5dgjavd71mnf-0 0}.lst-kix_8uacmh1uuah1-5>li:before{content:"" counter(lst-ctn-kix_8uacmh1uuah1-5,lower-roman) ". "}.lst-kix_5dgjavd71mnf-6>li:before{content:"" counter(lst-ctn-kix_5dgjavd71mnf-6,decimal) ". "}.lst-kix_5dgjavd71mnf-5>li:before{content:"" counter(lst-ctn-kix_5dgjavd71mnf-5,lower-roman) ". "}.lst-kix_mwk8aq9dzms2-2>li{counter-increment:lst-ctn-kix_mwk8aq9dzms2-2}ol.lst-kix_xd5kyx5b2yqr-5.start{counter-reset:lst-ctn-kix_xd5kyx5b2yqr-5 0}ol.lst-kix_5dgjavd71mnf-8.start{counter-reset:lst-ctn-kix_5dgjavd71mnf-8 0}.lst-kix_xd5kyx5b2yqr-4>li:before{content:"" counter(lst-ctn-kix_xd5kyx5b2yqr-4,lower-roman) ". "}ol.lst-kix_xd5kyx5b2yqr-4.start{counter-reset:lst-ctn-kix_xd5kyx5b2yqr-4 0}.lst-kix_5dgjavd71mnf-7>li:before{content:"" counter(lst-ctn-kix_5dgjavd71mnf-7,lower-latin) ". "}ol.lst-kix_xd5kyx5b2yqr-0.start{counter-reset:lst-ctn-kix_xd5kyx5b2yqr-0 0}.lst-kix_8uacmh1uuah1-6>li:before{content:"" counter(lst-ctn-kix_8uacmh1uuah1-6,decimal) ". "}.lst-kix_xd5kyx5b2yqr-4>li{counter-increment:lst-ctn-kix_xd5kyx5b2yqr-4}.lst-kix_mwk8aq9dzms2-8>li{counter-increment:lst-ctn-kix_mwk8aq9dzms2-8}.lst-kix_mwk8aq9dzms2-2>li:before{content:"" counter(lst-ctn-kix_mwk8aq9dzms2-2,lower-roman) ". "}.lst-kix_xd5kyx5b2yqr-5>li:before{content:"" counter(lst-ctn-kix_xd5kyx5b2yqr-5,decimal) ". "}ol.lst-kix_5dgjavd71mnf-7.start{counter-reset:lst-ctn-kix_5dgjavd71mnf-7 0}ol.lst-kix_xd5kyx5b2yqr-7.start{counter-reset:lst-ctn-kix_xd5kyx5b2yqr-7 0}.lst-kix_5dgjavd71mnf-2>li{counter-increment:lst-ctn-kix_5dgjavd71mnf-2}ol.lst-kix_8uacmh1uuah1-2{list-style-type:none}ol.lst-kix_8uacmh1uuah1-0.start{counter-reset:lst-ctn-kix_8uacmh1uuah1-0 0}ol.lst-kix_mwk8aq9dzms2-8.start{counter-reset:lst-ctn-kix_mwk8aq9dzms2-8 0}ol.lst-kix_8uacmh1uuah1-3{list-style-type:none}ol.lst-kix_8uacmh1uuah1-0{list-style-type:none}ol.lst-kix_8uacmh1uuah1-1{list-style-type:none}.lst-kix_xd5kyx5b2yqr-8>li:before{content:"" counter(lst-ctn-kix_xd5kyx5b2yqr-8,decimal) ". "}ol.lst-kix_8uacmh1uuah1-8{list-style-type:none}ol.lst-kix_mwk8aq9dzms2-4.start{counter-reset:lst-ctn-kix_mwk8aq9dzms2-4 0}ol.lst-kix_8uacmh1uuah1-7{list-style-type:none}ol.lst-kix_8uacmh1uuah1-6{list-style-type:none}.lst-kix_5dgjavd71mnf-1>li{counter-increment:lst-ctn-kix_5dgjavd71mnf-1}ol.lst-kix_8uacmh1uuah1-5{list-style-type:none}ol.lst-kix_8uacmh1uuah1-4{list-style-type:none}.lst-kix_mwk8aq9dzms2-7>li{counter-increment:lst-ctn-kix_mwk8aq9dzms2-7}.lst-kix_mwk8aq9dzms2-5>li{counter-increment:lst-ctn-kix_mwk8aq9dzms2-5}.lst-kix_8uacmh1uuah1-2>li{counter-increment:lst-ctn-kix_8uacmh1uuah1-2}ol.lst-kix_8uacmh1uuah1-5.start{counter-reset:lst-ctn-kix_8uacmh1uuah1-5 0}ol.lst-kix_mwk8aq9dzms2-7.start{counter-reset:lst-ctn-kix_mwk8aq9dzms2-7 0}.lst-kix_8uacmh1uuah1-6>li{counter-increment:lst-ctn-kix_8uacmh1uuah1-6}ol.lst-kix_xd5kyx5b2yqr-3.start{counter-reset:lst-ctn-kix_xd5kyx5b2yqr-3 0}ol.lst-kix_mwk8aq9dzms2-7{list-style-type:none}.lst-kix_mwk8aq9dzms2-0>li{counter-increment:lst-ctn-kix_mwk8aq9dzms2-0}ol.lst-kix_mwk8aq9dzms2-8{list-style-type:none}.lst-kix_5dgjavd71mnf-4>li{counter-increment:lst-ctn-kix_5dgjavd71mnf-4}.lst-kix_5dgjavd71mnf-3>li{counter-increment:lst-ctn-kix_5dgjavd71mnf-3}.lst-kix_5dgjavd71mnf-4>li:before{content:"" counter(lst-ctn-kix_5dgjavd71mnf-4,lower-latin) ". "}ol.lst-kix_mwk8aq9dzms2-3{list-style-type:none}ol.lst-kix_mwk8aq9dzms2-4{list-style-type:none}.lst-kix_xd5kyx5b2yqr-0>li{counter-increment:lst-ctn-kix_xd5kyx5b2yqr-0}ol.lst-kix_mwk8aq9dzms2-5{list-style-type:none}ol.lst-kix_mwk8aq9dzms2-6{list-style-type:none}.lst-kix_xd5kyx5b2yqr-6>li{counter-increment:lst-ctn-kix_xd5kyx5b2yqr-6}.lst-kix_5dgjavd71mnf-7>li{counter-increment:lst-ctn-kix_5dgjavd71mnf-7}.lst-kix_mwk8aq9dzms2-3>li{counter-increment:lst-ctn-kix_mwk8aq9dzms2-3}.lst-kix_mwk8aq9dzms2-4>li{counter-increment:lst-ctn-kix_mwk8aq9dzms2-4}.lst-kix_8uacmh1uuah1-7>li{counter-increment:lst-ctn-kix_8uacmh1uuah1-7}.lst-kix_mwk8aq9dzms2-5>li:before{content:"" counter(lst-ctn-kix_mwk8aq9dzms2-5,lower-roman) ". "}ol.lst-kix_5dgjavd71mnf-5.start{counter-reset:lst-ctn-kix_5dgjavd71mnf-5 0}.lst-kix_8uacmh1uuah1-8>li:before{content:"" counter(lst-ctn-kix_8uacmh1uuah1-8,lower-roman) ". "}.lst-kix_xd5kyx5b2yqr-7>li{counter-increment:lst-ctn-kix_xd5kyx5b2yqr-7}.lst-kix_mwk8aq9dzms2-6>li:before{content:"" counter(lst-ctn-kix_mwk8aq9dzms2-6,decimal) ". "}ol.lst-kix_8uacmh1uuah1-7.start{counter-reset:lst-ctn-kix_8uacmh1uuah1-7 0}ol.lst-kix_8uacmh1uuah1-2.start{counter-reset:lst-ctn-kix_8uacmh1uuah1-2 0}ol.lst-kix_mwk8aq9dzms2-1.start{counter-reset:lst-ctn-kix_mwk8aq9dzms2-1 0}ol.lst-kix_8uacmh1uuah1-3.start{counter-reset:lst-ctn-kix_8uacmh1uuah1-3 0}ol.lst-kix_8uacmh1uuah1-1.start{counter-reset:lst-ctn-kix_8uacmh1uuah1-1 0}.lst-kix_8uacmh1uuah1-4>li{counter-increment:lst-ctn-kix_8uacmh1uuah1-4}.lst-kix_xd5kyx5b2yqr-1>li{counter-increment:lst-ctn-kix_xd5kyx5b2yqr-1}.lst-kix_xd5kyx5b2yqr-6>li:before{content:"" counter(lst-ctn-kix_xd5kyx5b2yqr-6,lower-latin) ". "}.lst-kix_8uacmh1uuah1-8>li{counter-increment:lst-ctn-kix_8uacmh1uuah1-8}ol.lst-kix_xd5kyx5b2yqr-6.start{counter-reset:lst-ctn-kix_xd5kyx5b2yqr-6 0}.lst-kix_8uacmh1uuah1-1>li:before{content:"" counter(lst-ctn-kix_8uacmh1uuah1-1,lower-latin) ". "}.lst-kix_5dgjavd71mnf-5>li{counter-increment:lst-ctn-kix_5dgjavd71mnf-5}.lst-kix_8uacmh1uuah1-3>li:before{content:"" counter(lst-ctn-kix_8uacmh1uuah1-3,decimal) ". "}.lst-kix_mwk8aq9dzms2-7>li:before{content:"" counter(lst-ctn-kix_mwk8aq9dzms2-7,lower-latin) ". "}.lst-kix_xd5kyx5b2yqr-5>li{counter-increment:lst-ctn-kix_xd5kyx5b2yqr-5}.lst-kix_8uacmh1uuah1-5>li{counter-increment:lst-ctn-kix_8uacmh1uuah1-5}.lst-kix_8uacmh1uuah1-0>li{counter-increment:lst-ctn-kix_8uacmh1uuah1-0}ol.lst-kix_xd5kyx5b2yqr-8.start{counter-reset:lst-ctn-kix_xd5kyx5b2yqr-8 0}.lst-kix_mwk8aq9dzms2-4>li:before{content:"" counter(lst-ctn-kix_mwk8aq9dzms2-4,lower-latin) ". "}.lst-kix_5dgjavd71mnf-8>li{counter-increment:lst-ctn-kix_5dgjavd71mnf-8}ol.lst-kix_5dgjavd71mnf-6.start{counter-reset:lst-ctn-kix_5dgjavd71mnf-6 0}.lst-kix_5dgjavd71mnf-0>li{counter-increment:lst-ctn-kix_5dgjavd71mnf-0}ol.lst-kix_mwk8aq9dzms2-3.start{counter-reset:lst-ctn-kix_mwk8aq9dzms2-3 0}.lst-kix_8uacmh1uuah1-4>li:before{content:"" counter(lst-ctn-kix_8uacmh1uuah1-4,lower-latin) ". "}.lst-kix_xd5kyx5b2yqr-3>li:before{content:"" counter(lst-ctn-kix_xd5kyx5b2yqr-3,lower-latin) ". "}ol.lst-kix_8uacmh1uuah1-4.start{counter-reset:lst-ctn-kix_8uacmh1uuah1-4 0}.lst-kix_mwk8aq9dzms2-8>li:before{content:"" counter(lst-ctn-kix_mwk8aq9dzms2-8,lower-roman) ". "}ol.lst-kix_5dgjavd71mnf-3{list-style-type:none}.lst-kix_8uacmh1uuah1-1>li{counter-increment:lst-ctn-kix_8uacmh1uuah1-1}ol.lst-kix_5dgjavd71mnf-4{list-style-type:none}ol.lst-kix_5dgjavd71mnf-1{list-style-type:none}.lst-kix_xd5kyx5b2yqr-0>li:before{content:"" counter(lst-ctn-kix_xd5kyx5b2yqr-0,lower-latin) ". "}ol.lst-kix_5dgjavd71mnf-2.start{counter-reset:lst-ctn-kix_5dgjavd71mnf-2 0}ol.lst-kix_5dgjavd71mnf-2{list-style-type:none}.lst-kix_5dgjavd71mnf-0>li:before{content:"" counter(lst-ctn-kix_5dgjavd71mnf-0,upper-latin) ". "}ol.lst-kix_5dgjavd71mnf-7{list-style-type:none}ol.lst-kix_5dgjavd71mnf-8{list-style-type:none}ol.lst-kix_5dgjavd71mnf-5{list-style-type:none}ol.lst-kix_xd5kyx5b2yqr-2.start{counter-reset:lst-ctn-kix_xd5kyx5b2yqr-2 0}ol.lst-kix_5dgjavd71mnf-6{list-style-type:none}.lst-kix_5dgjavd71mnf-8>li:before{content:"" counter(lst-ctn-kix_5dgjavd71mnf-8,lower-roman) ". "}.lst-kix_5dgjavd71mnf-1>li:before{content:"" counter(lst-ctn-kix_5dgjavd71mnf-1,lower-latin) ". "}.lst-kix_5dgjavd71mnf-3>li:before{content:"" counter(lst-ctn-kix_5dgjavd71mnf-3,decimal) ". "}ol.lst-kix_5dgjavd71mnf-0{list-style-type:none}ol.lst-kix_mwk8aq9dzms2-2.start{counter-reset:lst-ctn-kix_mwk8aq9dzms2-2 0}ol.lst-kix_5dgjavd71mnf-4.start{counter-reset:lst-ctn-kix_5dgjavd71mnf-4 0}.lst-kix_xd5kyx5b2yqr-7>li:before{content:"" counter(lst-ctn-kix_xd5kyx5b2yqr-7,lower-roman) ". "}.lst-kix_mwk8aq9dzms2-6>li{counter-increment:lst-ctn-kix_mwk8aq9dzms2-6}.lst-kix_mwk8aq9dzms2-0>li:before{content:"" counter(lst-ctn-kix_mwk8aq9dzms2-0,decimal) ". "}.lst-kix_8uacmh1uuah1-7>li:before{content:"" counter(lst-ctn-kix_8uacmh1uuah1-7,lower-latin) ". "}.lst-kix_xd5kyx5b2yqr-2>li{counter-increment:lst-ctn-kix_xd5kyx5b2yqr-2}.lst-kix_xd5kyx5b2yqr-2>li:before{content:"" counter(lst-ctn-kix_xd5kyx5b2yqr-2,decimal) ". "}.lst-kix_8uacmh1uuah1-3>li{counter-increment:lst-ctn-kix_8uacmh1uuah1-3}.lst-kix_xd5kyx5b2yqr-8>li{counter-increment:lst-ctn-kix_xd5kyx5b2yqr-8}.lst-kix_5dgjavd71mnf-2>li:before{content:"" counter(lst-ctn-kix_5dgjavd71mnf-2,lower-roman) ". "}.lst-kix_mwk8aq9dzms2-3>li:before{content:"" counter(lst-ctn-kix_mwk8aq9dzms2-3,decimal) ". "}ol.lst-kix_xd5kyx5b2yqr-0{list-style-type:none}ol.lst-kix_xd5kyx5b2yqr-4{list-style-type:none}ol.lst-kix_xd5kyx5b2yqr-3{list-style-type:none}ol.lst-kix_xd5kyx5b2yqr-2{list-style-type:none}ol.lst-kix_xd5kyx5b2yqr-1{list-style-type:none}ol.lst-kix_xd5kyx5b2yqr-8{list-style-type:none}.lst-kix_mwk8aq9dzms2-1>li{counter-increment:lst-ctn-kix_mwk8aq9dzms2-1}ol.lst-kix_xd5kyx5b2yqr-7{list-style-type:none}ol.lst-kix_xd5kyx5b2yqr-6{list-style-type:none}.lst-kix_mwk8aq9dzms2-1>li:before{content:"" counter(lst-ctn-kix_mwk8aq9dzms2-1,lower-latin) ". "}ol.lst-kix_xd5kyx5b2yqr-5{list-style-type:none}.lst-kix_5dgjavd71mnf-6>li{counter-increment:lst-ctn-kix_5dgjavd71mnf-6}.lst-kix_8uacmh1uuah1-2>li:before{content:"" counter(lst-ctn-kix_8uacmh1uuah1-2,lower-roman) ". "}ol{margin:0;padding:0}.c0{widows:2;orphans:2;direction:ltr}.c7{max-width:468pt;background-color:#ffffff;padding:72pt 72pt 72pt 72pt}.c3{font-style:italic;font-weight:bold}.c4{padding-left:0pt;margin-left:72pt}.c2{margin:0;padding:0}.c5{padding-left:0pt;margin-left:36pt}.c6{margin-left:36pt}.c8{font-weight:bold}.c1{height:11pt}.title{widows:2;padding-top:0pt;line-height:1.15;orphans:2;text-align:left;color:#000000;font-size:21pt;font-family:"Trebuchet MS";padding-bottom:0pt;page-break-after:avoid}.subtitle{widows:2;padding-top:0pt;line-height:1.15;orphans:2;text-align:left;color:#666666;font-style:italic;font-size:13pt;font-family:"Trebuchet MS";padding-bottom:10pt;page-break-after:avoid}li{color:#000000;font-size:11pt;font-family:"Arial"}p{color:#000000;font-size:11pt;margin:0;font-family:"Arial"}h1{widows:2;padding-top:10pt;line-height:1.15;orphans:2;text-align:left;color:#000000;font-size:16pt;font-family:"Trebuchet MS";padding-bottom:0pt;page-break-after:avoid}h2{widows:2;padding-top:10pt;line-height:1.15;orphans:2;text-align:left;color:#000000;font-size:13pt;font-family:"Trebuchet MS";font-weight:bold;padding-bottom:0pt;page-break-after:avoid}h3{widows:2;padding-top:8pt;line-height:1.15;orphans:2;text-align:left;color:#666666;font-size:12pt;font-family:"Trebuchet MS";font-weight:bold;padding-bottom:0pt;page-break-after:avoid}h4{widows:2;padding-top:8pt;line-height:1.15;orphans:2;text-align:left;color:#666666;font-size:11pt;text-decoration:underline;font-family:"Trebuchet MS";padding-bottom:0pt;page-break-after:avoid}h5{widows:2;padding-top:8pt;line-height:1.15;orphans:2;text-align:left;color:#666666;font-size:11pt;font-family:"Trebuchet MS";padding-bottom:0pt;page-break-after:avoid}h6{widows:2;padding-top:8pt;line-height:1.15;orphans:2;text-align:left;color:#666666;font-style:italic;font-size:11pt;font-family:"Trebuchet MS";padding-bottom:0pt;page-break-after:avoid}</style></head><body class="c7"><p class="c0"><span class="c8">TEAM 9 ROBOT ARM WEBSITE</span></p><p class="c0 c1"><span class="c8"></span></p><p class="c0 c1"><span class="c8"></span></p><p class="c0"><span>ANALYSIS:</span></p><p class="c0 c1"><span></span></p><ol class="c2 lst-kix_mwk8aq9dzms2-0 start" start="1"><li class="c0 c5"><span>&nbsp;PATH PLANNING ALGORITHM:</span></li></ol><p class="c0 c6"><span>We are using the wavefront planner for path planning. &nbsp;We represent the configuration space as a grid where the x axis consists of the angles for the first link, and the y axis consists of the angles for the second link. &nbsp;We represent the obstacles in this space, and input into the planner the goal angles for the first and second link (using inverse kinematics), and our starting angle. &nbsp;Our resolution for the grid is 20 degrees. &nbsp;We have 4 point connectivity. &nbsp;The wavefront planner outputs a list of points on the grid (meaning a list of angles for the first and second link) for the two link arm to travel to to get to the goal. &nbsp;Since this will result in the arm going to the nearest 20 degree grid block to the goal, and not its exact location, we then command for the arm to go to the exact goal location. &nbsp;</span></p><p class="c0 c1 c6"><span></span></p><p class="c0"><span>2. &nbsp;IMPROVEMENTS</span></p><ol class="c2 lst-kix_5dgjavd71mnf-0 start" start="1"><li class="c0 c5"><span>&nbsp;SOFTWARE</span></li></ol><ol class="c2 lst-kix_5dgjavd71mnf-1 start" start="1"><li class="c0 c4"><span>We used a simple function to command the arm to go to a specific encoder value. &nbsp;We could have however used a PID controller, which would have helped us with minimizing overshoot, accumulative error, and thus accuracy.</span></li><li class="c0 c4"><span>We could figure out a way to improve resolution for our grid without using too much memory in the wavefront planner. &nbsp;This would require us to figure out how to make linked lists more efficiently on the stack (since robot c does not have dynamic allocation)</span></li></ol><ol class="c2 lst-kix_5dgjavd71mnf-0" start="2"><li class="c0 c5"><span>ROBOT ARM DESIGN</span></li></ol><ol class="c2 lst-kix_5dgjavd71mnf-1 start" start="1"><li class="c0 c4"><span>We could somehow make the first link lighter so that it does not drag as much on the board, making accuracy better.</span></li><li class="c0 c4"><span>We could redesign the robot so that the motor does not physically move with our link. &nbsp;</span></li></ol><p class="c0"><span>3. &nbsp;ROBOT CONFIGURATION SPACE </span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.85px; height: 289.50px;"><img alt="" src="images/image00.png" style="width: 566.85px; height: 289.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>4. &nbsp;THIRD ARM</span></p><ol class="c2 lst-kix_8uacmh1uuah1-0 start" start="1"><li class="c0 c5"><span>&nbsp;HOW IS PLANNER AFFECTED</span></li></ol><ol class="c2 lst-kix_8uacmh1uuah1-1 start" start="1"><li class="c0 c4"><span>If we use our current wavefront planner, we would now have plan in three dimensions. &nbsp;We could do this by using BFS, and marking all points that are distance d from the start location in all dimensions for all d. &nbsp;However, this will add a factor of n to the big-oh of the program, where n is the number of boxes we discretize the angles for each arm link. &nbsp;Thus, if the wavefront planner took O(n^2) to execute in 2 dimensions, this algorithm will take O(n^3) to execute in 3 dimensions.</span></li></ol><p class="c0 c1"><span></span></p><ol class="c2 lst-kix_8uacmh1uuah1-0" start="2"><li class="c0 c5"><span>CHANGES NEEDED FOR EFFICIENCY</span></li></ol><ol class="c2 lst-kix_8uacmh1uuah1-1 start" start="1"><li class="c0 c4"><span>Now we are going to have lots of theta1, theta2, and theta3 that will correspond to a single X,Y,Z coordinate. &nbsp;For the set of valid Theta1,theta2,theta3, &nbsp;filter out those that will result in hitting an obstacle (we know this from looking at the configuration space). &nbsp;Then choose Theta1,theta2,theta3 which minimizes the following expression sqrt((Theta1-startTheta1)^2+(Theta1-startTheta2)^2+(Theta1-startTheta2)^2)</span></li></ol><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span class="c3">code (main.c)</span></p><p class="c0"><span>pragma config(Sensor, S1, &nbsp; &nbsp; button, &nbsp; &nbsp; &nbsp; &nbsp; sensorTouch)</span></p><p class="c0"><span>#pragma config(Motor, &nbsp;motorA, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Arm1, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tmotorNXT, PIDControl, encoder)</span></p><p class="c0"><span>#pragma config(Motor, &nbsp;motorB, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Arm2, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tmotorNXT, PIDControl, encoder)</span></p><p class="c0"><span>//*!!Code automatically generated by &#39;ROBOTC&#39; configuration wizard &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !!*//</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>#include &quot;robotArm2.c&quot;</span></p><p class="c0"><span>#include &quot;waveFrontDir2.c&quot;</span></p><p class="c0"><span>#include &quot;results.c&quot;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>float XA = 4.5;</span></p><p class="c0"><span>float YA = 2;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>float XB = -4;</span></p><p class="c0"><span>float YB = 4;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>float goalDeg1;</span></p><p class="c0"><span>float goalDeg2;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>float goalCol;</span></p><p class="c0"><span>float goalRow;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>float startRow = 9;</span></p><p class="c0"><span>float startCol = 9;</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>path pathArray;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>void calcPath(){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goalCol = fromDegreesToBox(goalDeg1);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goalRow = fromDegreesToBox(goalDeg2 );</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;calcPath(&amp;pathArray, goalRow, goalCol, startRow, startCol);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(pathArray.validPath) return;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goalCol = fromDegreesToBox(goalDeg1 - 20);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goalRow = fromDegreesToBox(goalDeg2 );</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;calcPath(&amp;pathArray, goalRow, goalCol, startRow, startCol);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(pathArray.validPath) return;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goalCol = fromDegreesToBox(goalDeg1 + 20);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goalRow = fromDegreesToBox(goalDeg2 );</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;calcPath(&amp;pathArray, goalRow, goalCol, startRow, startCol);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(pathArray.validPath) return;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goalCol = fromDegreesToBox(goalDeg1);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goalRow = fromDegreesToBox(goalDeg2 - 20 );</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;calcPath(&amp;pathArray, goalRow, goalCol, startRow, startCol);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(pathArray.validPath) return;</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goalCol = fromDegreesToBox(goalDeg1);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goalRow = fromDegreesToBox(goalDeg2 + 20 );</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;calcPath(&amp;pathArray, goalRow, goalCol, startRow, startCol);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(pathArray.validPath) return;</span></p><p class="c0"><span>}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>void findTheta(float X, float Y){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initializeThing();</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float goalRad2 = (getGoalDegree2(X, Y, false);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float goalRad1 = getGoalDegree1(X, Y, goalRad2);</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goalDeg1 = radiansToDegrees(goalRad1);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goalDeg2 = radiansToDegrees(goalRad2);</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(goalDeg1 &gt;= 0 &amp;&amp; goalDeg1 &lt;= 180){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(goalDeg2 &lt; Meena.matrix[goalDeg1][0] || goalDeg2 &gt; Meena.matrix[goalDeg1][0]) return;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goalRad2 = (getGoalDegree2(X, Y, true);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goalRad1 = getGoalDegree1(X, Y, goalRad2);</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goalDeg1 = radiansToDegrees(goalRad1);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goalDeg2 = radiansToDegrees(goalRad2);</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(goalDeg1 &gt;= 0 &amp;&amp; goalDeg1 &lt;= 180){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(goalDeg2 &lt; Meena.matrix[goalDeg1][0] || goalDeg2 &gt; Meena.matrix[goalDeg1][0]) return;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>void goToTarget(float X, float Y)</span></p><p class="c0"><span>{</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//// &nbsp; &nbsp;SETUP //////////////////////////////////</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//CHANGE THIS TO CHECK WHETHER THESE ARE VALID</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;findTheta(X, Y);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//CHANGE THIS TO CHECK WHETHER THESE ARE VALID</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;calcPath();</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///////////// END SETUP///////////////////////////</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i = 1;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while( i &lt; pathArray.pathLength){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int theta1 = fromBoxToDegrees(pathArray.waypoints[i].c);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int theta2 = fromBoxToDegrees(pathArray.waypoints[i].r);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goToDegree(theta1, theta2);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i = i + 1;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goToExactGoal(goalDeg1, goalDeg2);</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startRow = goalRow;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startCol = goalCol;</span></p><p class="c0"><span>}</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>task main{</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goToTarget(-XA, YA);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(!sensorValue[button]){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wait10Msec(1);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goToTarget(-XB, YB);</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(!sensorValue[button]){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wait10Msec(1);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goToTarget(-XA, YA);</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(!sensorValue[button]){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wait10Msec(1);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goToTarget(-6.25, 0);</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span class="c3">code wavefront.c</span></p><p class="c0"><span>typedef struct space</span></p><p class="c0"><span>{</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int matrix[19][10]; //change to fit gridsize</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int rows;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int cols;</span></p><p class="c0"><span>} space;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>typedef struct node</span></p><p class="c0"><span>{</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct node* prev;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct node* next;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int r;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int c;</span></p><p class="c0"><span>} node;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>typedef struct queue</span></p><p class="c0"><span>{ node* front;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node* back;</span></p><p class="c0"><span>} queue;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>typedef struct loc</span></p><p class="c0"><span>{</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float r;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float c;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float dist;</span></p><p class="c0"><span>}loc;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>typedef struct path{</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loc waypoints[100];</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int pathLength;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float dir[2];</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool validPath;</span></p><p class="c0"><span>}path;</span></p><p class="c0"><span>&nbsp;//#define NULL ((void *)0)</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>node neighbors[500]; /// might need to be changed to handle larger grid</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>loc temp[100];</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>bool is4pt=true;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>struct space S_full;</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>/*</span></p><p class="c0"><span>{{0, 0, 0, 1, 1, 0, 0, 0},</span></p><p class="c0"><span>{0, 0, 0, 1, 1, 0, 0, 0},</span></p><p class="c0"><span>{0, 0, 1, 1, 1, 0, 0, 0},</span></p><p class="c0"><span>{0, 0, 1, 1, 0, 0, 0, 0},</span></p><p class="c0"><span>{0, 0, 0, 1, 1, 1, 0, 0},</span></p><p class="c0"><span>{0, 0, 1, 1, 1, 1, 0, 0},</span></p><p class="c0"><span>{0, 0, 1, 1, 1, 0, 0, 0},</span></p><p class="c0"><span>{0, 0, 0, 1, 1, 0, 0, 0},</span></p><p class="c0"><span>{0, 0, 0, 1, 1, 1, 0, 0},</span></p><p class="c0"><span>{0, 1, 1, 0, 1, 0, 0, 0},</span></p><p class="c0"><span>{0, 1, 1, 0, 0, 0, 1, 0},</span></p><p class="c0"><span>{0, 0, 0, 0, 0, 0, 1, 0},</span></p><p class="c0"><span>{0, 0, 0, 0, 1, 1, 0, 0},</span></p><p class="c0"><span>{0, 0, 0, 0, 1, 1, 1, 1},</span></p><p class="c0"><span>{0, 0, 0, 0, 0, 0, 1, 1},</span></p><p class="c0"><span>{0, 0, 0, 0, 0, 0, 0, 0}};</span></p><p class="c0"><span>*/</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>bool isEmpty(queue* Q){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(Q-&gt;back) return false;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else return true;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>}</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>void enq(queue* Q,node* n){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (isEmpty(Q)){</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q-&gt;front=n;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q-&gt;back=n;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n-&gt;prev=NULL;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n-&gt;next=NULL;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q-&gt;back-&gt;next=n;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n-&gt;prev=Q-&gt;back;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q-&gt;back=n;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n-&gt;next=NULL;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>}</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>bool fourPoint(int dr,int dc){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (is4pt &amp;&amp;((dc*dr)==0));</span></p><p class="c0"><span>}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>node* deq(queue* Q){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Q==NULL) ASSERT(false);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node* n=Q-&gt;front;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Q-&gt;front==NULL) ASSERT(false);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q-&gt;front=Q-&gt;front-&gt;next;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Q-&gt;front==NULL){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q-&gt;back=NULL;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q-&gt;front-&gt;prev=NULL;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return n;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>bool isInBounds(int r,int c, space* S){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (r&gt;=0)&amp;&amp;(c&gt;=0)&amp;&amp;(r&lt;(S-&gt;rows))&amp;&amp;(c&lt;(S-&gt;cols));</span></p><p class="c0"><span>}</span></p><p class="c0"><span>int findMinAdjRC(space* S,int r,int c, int rDir,int cDir){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int currR;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int currC;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int dr;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int dc;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int minR=r;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int minC=c;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int minVal=1000;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int dist;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//check the one that is in its direction</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int inDirR=r+rDir;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int inDirC=c+cDir;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((isInBounds(inDirR,inDirC,S)) &amp;&amp;(!(S-&gt;matrix[inDirR][inDirC]==1))){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((S-&gt;matrix[inDirR][inDirC])&lt;((S-&gt;matrix[r][c]))){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return inDirR*(S-&gt;cols)+inDirC;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (dr=-1;dr&lt;=1;dr++){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (dc=-1;dc&lt;=1;dc++){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((!((dr==0) &amp;&amp; (dc==0)))&amp;&amp;((dc*dr)==0)){//</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currR=r+dr;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currC=c+dc;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((isInBounds(currR,currC,S)) &amp;&amp;(!(S-&gt;matrix[currR][currC]==1))){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dist=S-&gt;matrix[currR][currC];</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (dist&lt;minVal){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;minVal=dist;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;minR=currR;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;minC=currC;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return minR*(S-&gt;cols)+minC;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>int getRow(space* S,int index){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return index/(S-&gt;cols);</span></p><p class="c0"><span>}</span></p><p class="c0"><span>int getCol(space* S,int index){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return index % (S-&gt;cols);</span></p><p class="c0"><span>}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>void findPath(space*S,int startR,int startC, path* pathArray, int rDir, int cDir){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int rowColIndex;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int prevR;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int prevC;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int r=startR;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int c=startC;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathArray-&gt;waypoints[1].r=startR;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathArray-&gt;waypoints[1].c=startC;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int arrayIndex=2;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(true){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rowColIndex=findMinAdjRC(S,r,c,rDir,cDir);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prevR=r;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prevC=c;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r=getRow(S,rowColIndex);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c=getCol(S,rowColIndex);</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rDir=r-prevR;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cDir=c-prevC;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathArray-&gt;waypoints[arrayIndex].r=r;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathArray-&gt;waypoints[arrayIndex].c=c;</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((S-&gt;matrix[r][c])==2) {</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathArray-&gt;dir[0] = rDir;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathArray-&gt;dir[1] = cDir;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrayIndex++;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrayIndex++;</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathArray-&gt;pathLength=arrayIndex;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//-1 R -1 C DENOTES END OF PATH</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathArray-&gt;waypoints[arrayIndex+1].r=-1;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathArray-&gt;waypoints[arrayIndex+1].c=-1;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>int calcDist (int x1, int y1, int x2, int y2) {</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return abs(x1 - x2) + abs(y1 - y2);</span></p><p class="c0"><span>}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>void getCritical(path* pathArray) {</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int prevR,prevC;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int currR, currC;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int nextR, nextC;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int dirx1, dirx2, diry1, diry2;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int currIndex = 0;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int counter = 0;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int distTotal = 0;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp = *pathArray;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp[counter].r = pathArray-&gt;waypoints[currIndex].r;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp[counter].c = pathArray-&gt;waypoints[currIndex].c;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counter = counter + 1;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do {</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nextR = pathArray-&gt;waypoints[currIndex + 2].r;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nextC = pathArray-&gt;waypoints[currIndex + 2].c;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currR = pathArray-&gt;waypoints[currIndex + 1].r;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currC = pathArray-&gt;waypoints[currIndex + 1].c;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prevR = pathArray-&gt;waypoints[currIndex].r;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prevC = pathArray-&gt;waypoints[currIndex].c;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dirx1 = currR - prevR;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dirx2 = nextR - currR;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;diry1 = currC - prevC;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;diry2 = nextC - currC;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((dirx1 != dirx2) || (diry1 != diry2)) {</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp[counter].r = pathArray-&gt;waypoints[currIndex + 1].r;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp[counter].c = pathArray-&gt;waypoints[currIndex + 1].c;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counter = counter + 1;</span></p><p class="c0"><span>&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; currIndex = currIndex + 1;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} while ((nextR != -1) &amp;&amp; (nextC != -1));</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp[counter].r = currR;</span></p><p class="c0"><span>&nbsp; temp[counter].c = currC;</span></p><p class="c0"><span>&nbsp; counter = counter + 1;</span></p><p class="c0"><span>&nbsp; temp[counter].r = -1;</span></p><p class="c0"><span>&nbsp; temp[counter].c = -1;</span></p><p class="c0"><span>&nbsp; for (int i = 0; i &lt; counter + 1; i++) {</span></p><p class="c0"><span>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathArray-&gt;waypoints[i].r = temp[i].r;</span></p><p class="c0"><span>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathArray-&gt;waypoints[i].c = temp[i].c;</span></p><p class="c0"><span>&nbsp; &nbsp; if (i &gt;= counter - 1) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; pathArray-&gt;waypoints[i].dist = 0;</span></p><p class="c0"><span>&nbsp; &nbsp; } else {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; pathArray-&gt;waypoints[i].dist = calcDist(temp[i + 1].r, temp[i + 1].c, temp[i].r, temp[i].c);</span></p><p class="c0"><span>&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; distTotal = distTotal + pathArray-&gt;waypoints[i].dist;</span></p><p class="c0"><span>&nbsp; }</span></p><p class="c0"><span>&nbsp; pathArray-&gt;pathLength = distTotal;</span></p><p class="c0"><span>}</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>void wavefront(int r,int c, space* S){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int label=2;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int dr;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int dc;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int neighbR;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int neighbC;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node* neighbor;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int neighbIdx=0;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue Q;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q.front=NULL;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q.back=NULL;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node firstNode;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;firstNode.r=r;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;firstNode.c=c;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S-&gt;matrix[r][c]=label;</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enq(&amp;Q, &amp;firstNode);</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node* currNode;</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (!(isEmpty(&amp;Q))){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currNode=deq(&amp;Q);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r=currNode-&gt;r;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c=currNode-&gt;c;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (dr=-1;dr&lt;=1;dr++){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (dc=-1;dc&lt;=1;dc++){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((!((dr==0) &amp;&amp; (dc==0)))&amp;&amp;((dc*dr)==0)){//</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbR=r+dr;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbC=c+dc;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((isInBounds(neighbR,neighbC,S))&amp;&amp;(S-&gt;matrix[neighbR][neighbC]==0)){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S-&gt;matrix[neighbR][neighbC]=S-&gt;matrix[r][c]+1;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbor=&amp;neighbors[neighbIdx];</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbIdx++;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbor-&gt;r=neighbR;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbor-&gt;c=neighbC;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enq(&amp;Q,neighbor);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>void initializeStuff(path *pathArray){</span></p><p class="c0"><span>&nbsp; S_full.cols = 10;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S_full.rows = 19;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int i = 0; i &lt; S_full.rows; i++){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int j = 0; j &lt; S_full.cols; j++){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S_full.matrix[i][j] = 0;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S_full.matrix[0][0] = 1;S_full.matrix[0][1] = 1;</span></p><p class="c0"><span>&nbsp; S_full.matrix[1][0] = 1;S_full.matrix[1][1] = 1;</span></p><p class="c0"><span>&nbsp; S_full.matrix[2][0] = 1;S_full.matrix[2][1] = 1;</span></p><p class="c0"><span>&nbsp; S_full.matrix[3][0] = 1;S_full.matrix[3][1] = 1;</span></p><p class="c0"><span>&nbsp; S_full.matrix[4][0] = 1;S_full.matrix[4][1] = 1;</span></p><p class="c0"><span>&nbsp; S_full.matrix[5][0] = 1;S_full.matrix[5][1] = 1;</span></p><p class="c0"><span>&nbsp; S_full.matrix[6][0] = 1;S_full.matrix[6][1] = 1;</span></p><p class="c0"><span>&nbsp; S_full.matrix[7][0] = 1;S_full.matrix[8][0] = 1;</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;S_full.matrix[6][4] = 1;S_full.matrix[6][5] = 1; S_full.matrix[6][6] = 1;</span></p><p class="c0"><span>&nbsp;S_full.matrix[7][4] = 1;S_full.matrix[7][5] = 1; S_full.matrix[7][6] = 1;S_full.matrix[7][3] = 1;</span></p><p class="c0"><span>&nbsp;S_full.matrix[8][3] = 1;S_full.matrix[8][4] = 1;S_full.matrix[8][5] = 1;S_full.matrix[8][6] = 1;</span></p><p class="c0"><span>&nbsp;S_full.matrix[9][3] = 1;S_full.matrix[9][4] = 1;S_full.matrix[9][5] = 1;</span></p><p class="c0"><span>&nbsp;S_full.matrix[10][2] = 1;S_full.matrix[10][3] = 1;S_full.matrix[10][4] = 1;S_full.matrix[10][5] = 1;</span></p><p class="c0"><span>&nbsp;S_full.matrix[11][2] = 1;S_full.matrix[11][3] = 1;S_full.matrix[10][4] = 1;S_full.matrix[12][2]</span></p><p class="c0"><span>&nbsp;S_full.matrix[12][5] = 1;S_full.matrix[12][4] = 1;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;S_full.matrix[9][8]=1;</span></p><p class="c0"><span>S_full.matrix[10][8]=1;</span></p><p class="c0"><span>S_full.matrix[11][8]=1;</span></p><p class="c0"><span>S_full.matrix[12][8]=1;</span></p><p class="c0"><span>S_full.matrix[13][8]=1;</span></p><p class="c0"><span>S_full.matrix[14][8]=1;</span></p><p class="c0"><span>S_full.matrix[15][8]=1;</span></p><p class="c0"><span>S_full.matrix[16][8]=1;</span></p><p class="c0"><span>S_full.matrix[17][8]=1;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>S_full.matrix[12][7]=1;</span></p><p class="c0"><span>S_full.matrix[13][7]=1;</span></p><p class="c0"><span>S_full.matrix[14][7]=1;</span></p><p class="c0"><span>S_full.matrix[15][7]=1;</span></p><p class="c0"><span>S_full.matrix[16][7]=1;</span></p><p class="c0"><span>S_full.matrix[17][7]=1;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int i = 0; i &lt; 500; i++){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbors[i].r = 0;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbors[i].c = 0;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbors[i].prev = NULL;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbors[i].next = NULL;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathArray-&gt;validPath = false;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathArray-&gt;pathLength = 0;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int i = 0; i &lt; 100; i ++){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathArray-&gt;waypoints[i].r = 0;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathArray-&gt;waypoints[i].c = 0;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathArray-&gt;waypoints[i].dist = 0;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp[i].r = 0;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp[i].c = 0;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp[i].dist = 0;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>}</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>void calcPath(path* pathArray, int goalRow, int goalCol, int startRow, int startCol)</span></p><p class="c0"><span>{</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initializeStuff(pathArray);</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(goalRow &gt; 0 &amp;&amp; goalCol &lt; S_full.rows){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(goalCol &gt; 0 &amp;&amp; goalRow &lt; S_full.rows){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(S_full.matrix[goalRow][goalCol] == 1) return;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else return;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else return;</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathArray-&gt;validPath = true;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wavefront(goalRow,goalCol,&amp;S_full);</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;findPath(&amp;S_full,startRow,startCol,pathArray,1,0);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//getCritical(pathArray);</span></p><p class="c0"><span>}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>typedef struct space</span></p><p class="c0"><span>{</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int matrix[19][10]; //change to fit gridsize</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int rows;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int cols;</span></p><p class="c0"><span>} space;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>typedef struct node</span></p><p class="c0"><span>{</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct node* prev;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct node* next;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int r;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int c;</span></p><p class="c0"><span>} node;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>typedef struct queue</span></p><p class="c0"><span>{ node* front;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node* back;</span></p><p class="c0"><span>} queue;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>typedef struct loc</span></p><p class="c0"><span>{</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float r;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float c;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float dist;</span></p><p class="c0"><span>}loc;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>typedef struct path{</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loc waypoints[100];</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int pathLength;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float dir[2];</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool validPath;</span></p><p class="c0"><span>}path;</span></p><p class="c0"><span>&nbsp;//#define NULL ((void *)0)</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>node neighbors[500]; /// might need to be changed to handle larger grid</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>loc temp[100];</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>bool is4pt=true;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>struct space S_full;</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>/*</span></p><p class="c0"><span>{{0, 0, 0, 1, 1, 0, 0, 0},</span></p><p class="c0"><span>{0, 0, 0, 1, 1, 0, 0, 0},</span></p><p class="c0"><span>{0, 0, 1, 1, 1, 0, 0, 0},</span></p><p class="c0"><span>{0, 0, 1, 1, 0, 0, 0, 0},</span></p><p class="c0"><span>{0, 0, 0, 1, 1, 1, 0, 0},</span></p><p class="c0"><span>{0, 0, 1, 1, 1, 1, 0, 0},</span></p><p class="c0"><span>{0, 0, 1, 1, 1, 0, 0, 0},</span></p><p class="c0"><span>{0, 0, 0, 1, 1, 0, 0, 0},</span></p><p class="c0"><span>{0, 0, 0, 1, 1, 1, 0, 0},</span></p><p class="c0"><span>{0, 1, 1, 0, 1, 0, 0, 0},</span></p><p class="c0"><span>{0, 1, 1, 0, 0, 0, 1, 0},</span></p><p class="c0"><span>{0, 0, 0, 0, 0, 0, 1, 0},</span></p><p class="c0"><span>{0, 0, 0, 0, 1, 1, 0, 0},</span></p><p class="c0"><span>{0, 0, 0, 0, 1, 1, 1, 1},</span></p><p class="c0"><span>{0, 0, 0, 0, 0, 0, 1, 1},</span></p><p class="c0"><span>{0, 0, 0, 0, 0, 0, 0, 0}};</span></p><p class="c0"><span>*/</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>bool isEmpty(queue* Q){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(Q-&gt;back) return false;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else return true;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>}</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>void enq(queue* Q,node* n){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (isEmpty(Q)){</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q-&gt;front=n;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q-&gt;back=n;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n-&gt;prev=NULL;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n-&gt;next=NULL;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q-&gt;back-&gt;next=n;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n-&gt;prev=Q-&gt;back;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q-&gt;back=n;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n-&gt;next=NULL;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>}</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>bool fourPoint(int dr,int dc){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (is4pt &amp;&amp;((dc*dr)==0));</span></p><p class="c0"><span>}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>node* deq(queue* Q){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Q==NULL) ASSERT(false);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node* n=Q-&gt;front;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Q-&gt;front==NULL) ASSERT(false);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q-&gt;front=Q-&gt;front-&gt;next;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Q-&gt;front==NULL){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q-&gt;back=NULL;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q-&gt;front-&gt;prev=NULL;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return n;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>bool isInBounds(int r,int c, space* S){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (r&gt;=0)&amp;&amp;(c&gt;=0)&amp;&amp;(r&lt;(S-&gt;rows))&amp;&amp;(c&lt;(S-&gt;cols));</span></p><p class="c0"><span>}</span></p><p class="c0"><span>int findMinAdjRC(space* S,int r,int c, int rDir,int cDir){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int currR;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int currC;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int dr;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int dc;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int minR=r;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int minC=c;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int minVal=1000;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int dist;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//check the one that is in its direction</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int inDirR=r+rDir;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int inDirC=c+cDir;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((isInBounds(inDirR,inDirC,S)) &amp;&amp;(!(S-&gt;matrix[inDirR][inDirC]==1))){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((S-&gt;matrix[inDirR][inDirC])&lt;((S-&gt;matrix[r][c]))){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return inDirR*(S-&gt;cols)+inDirC;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (dr=-1;dr&lt;=1;dr++){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (dc=-1;dc&lt;=1;dc++){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((!((dr==0) &amp;&amp; (dc==0)))&amp;&amp;((dc*dr)==0)){//</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currR=r+dr;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currC=c+dc;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((isInBounds(currR,currC,S)) &amp;&amp;(!(S-&gt;matrix[currR][currC]==1))){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dist=S-&gt;matrix[currR][currC];</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (dist&lt;minVal){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;minVal=dist;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;minR=currR;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;minC=currC;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return minR*(S-&gt;cols)+minC;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>int getRow(space* S,int index){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return index/(S-&gt;cols);</span></p><p class="c0"><span>}</span></p><p class="c0"><span>int getCol(space* S,int index){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return index % (S-&gt;cols);</span></p><p class="c0"><span>}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>void findPath(space*S,int startR,int startC, path* pathArray, int rDir, int cDir){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int rowColIndex;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int prevR;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int prevC;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int r=startR;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int c=startC;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathArray-&gt;waypoints[1].r=startR;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathArray-&gt;waypoints[1].c=startC;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int arrayIndex=2;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(true){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rowColIndex=findMinAdjRC(S,r,c,rDir,cDir);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prevR=r;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prevC=c;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r=getRow(S,rowColIndex);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c=getCol(S,rowColIndex);</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rDir=r-prevR;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cDir=c-prevC;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathArray-&gt;waypoints[arrayIndex].r=r;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathArray-&gt;waypoints[arrayIndex].c=c;</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((S-&gt;matrix[r][c])==2) {</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathArray-&gt;dir[0] = rDir;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathArray-&gt;dir[1] = cDir;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrayIndex++;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrayIndex++;</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathArray-&gt;pathLength=arrayIndex;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//-1 R -1 C DENOTES END OF PATH</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathArray-&gt;waypoints[arrayIndex+1].r=-1;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathArray-&gt;waypoints[arrayIndex+1].c=-1;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>int calcDist (int x1, int y1, int x2, int y2) {</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return abs(x1 - x2) + abs(y1 - y2);</span></p><p class="c0"><span>}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>void getCritical(path* pathArray) {</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int prevR,prevC;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int currR, currC;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int nextR, nextC;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int dirx1, dirx2, diry1, diry2;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int currIndex = 0;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int counter = 0;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int distTotal = 0;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp = *pathArray;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp[counter].r = pathArray-&gt;waypoints[currIndex].r;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp[counter].c = pathArray-&gt;waypoints[currIndex].c;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counter = counter + 1;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do {</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nextR = pathArray-&gt;waypoints[currIndex + 2].r;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nextC = pathArray-&gt;waypoints[currIndex + 2].c;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currR = pathArray-&gt;waypoints[currIndex + 1].r;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currC = pathArray-&gt;waypoints[currIndex + 1].c;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prevR = pathArray-&gt;waypoints[currIndex].r;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prevC = pathArray-&gt;waypoints[currIndex].c;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dirx1 = currR - prevR;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dirx2 = nextR - currR;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;diry1 = currC - prevC;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;diry2 = nextC - currC;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((dirx1 != dirx2) || (diry1 != diry2)) {</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp[counter].r = pathArray-&gt;waypoints[currIndex + 1].r;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp[counter].c = pathArray-&gt;waypoints[currIndex + 1].c;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counter = counter + 1;</span></p><p class="c0"><span>&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; currIndex = currIndex + 1;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} while ((nextR != -1) &amp;&amp; (nextC != -1));</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp[counter].r = currR;</span></p><p class="c0"><span>&nbsp; temp[counter].c = currC;</span></p><p class="c0"><span>&nbsp; counter = counter + 1;</span></p><p class="c0"><span>&nbsp; temp[counter].r = -1;</span></p><p class="c0"><span>&nbsp; temp[counter].c = -1;</span></p><p class="c0"><span>&nbsp; for (int i = 0; i &lt; counter + 1; i++) {</span></p><p class="c0"><span>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathArray-&gt;waypoints[i].r = temp[i].r;</span></p><p class="c0"><span>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathArray-&gt;waypoints[i].c = temp[i].c;</span></p><p class="c0"><span>&nbsp; &nbsp; if (i &gt;= counter - 1) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; pathArray-&gt;waypoints[i].dist = 0;</span></p><p class="c0"><span>&nbsp; &nbsp; } else {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; pathArray-&gt;waypoints[i].dist = calcDist(temp[i + 1].r, temp[i + 1].c, temp[i].r, temp[i].c);</span></p><p class="c0"><span>&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; distTotal = distTotal + pathArray-&gt;waypoints[i].dist;</span></p><p class="c0"><span>&nbsp; }</span></p><p class="c0"><span>&nbsp; pathArray-&gt;pathLength = distTotal;</span></p><p class="c0"><span>}</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>void wavefront(int r,int c, space* S){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int label=2;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int dr;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int dc;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int neighbR;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int neighbC;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node* neighbor;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int neighbIdx=0;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue Q;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q.front=NULL;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q.back=NULL;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node firstNode;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;firstNode.r=r;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;firstNode.c=c;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S-&gt;matrix[r][c]=label;</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enq(&amp;Q, &amp;firstNode);</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node* currNode;</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (!(isEmpty(&amp;Q))){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currNode=deq(&amp;Q);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r=currNode-&gt;r;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c=currNode-&gt;c;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (dr=-1;dr&lt;=1;dr++){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (dc=-1;dc&lt;=1;dc++){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((!((dr==0) &amp;&amp; (dc==0)))&amp;&amp;((dc*dr)==0)){//</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbR=r+dr;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbC=c+dc;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((isInBounds(neighbR,neighbC,S))&amp;&amp;(S-&gt;matrix[neighbR][neighbC]==0)){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S-&gt;matrix[neighbR][neighbC]=S-&gt;matrix[r][c]+1;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbor=&amp;neighbors[neighbIdx];</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbIdx++;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbor-&gt;r=neighbR;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbor-&gt;c=neighbC;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enq(&amp;Q,neighbor);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>void initializeStuff(path *pathArray){</span></p><p class="c0"><span>&nbsp; S_full.cols = 10;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S_full.rows = 19;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int i = 0; i &lt; S_full.rows; i++){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int j = 0; j &lt; S_full.cols; j++){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S_full.matrix[i][j] = 0;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S_full.matrix[0][0] = 1;S_full.matrix[0][1] = 1;</span></p><p class="c0"><span>&nbsp; S_full.matrix[1][0] = 1;S_full.matrix[1][1] = 1;</span></p><p class="c0"><span>&nbsp; S_full.matrix[2][0] = 1;S_full.matrix[2][1] = 1;</span></p><p class="c0"><span>&nbsp; S_full.matrix[3][0] = 1;S_full.matrix[3][1] = 1;</span></p><p class="c0"><span>&nbsp; S_full.matrix[4][0] = 1;S_full.matrix[4][1] = 1;</span></p><p class="c0"><span>&nbsp; S_full.matrix[5][0] = 1;S_full.matrix[5][1] = 1;</span></p><p class="c0"><span>&nbsp; S_full.matrix[6][0] = 1;S_full.matrix[6][1] = 1;</span></p><p class="c0"><span>&nbsp; S_full.matrix[7][0] = 1;S_full.matrix[8][0] = 1;</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;S_full.matrix[6][4] = 1;S_full.matrix[6][5] = 1; S_full.matrix[6][6] = 1;</span></p><p class="c0"><span>&nbsp;S_full.matrix[7][4] = 1;S_full.matrix[7][5] = 1; S_full.matrix[7][6] = 1;S_full.matrix[7][3] = 1;</span></p><p class="c0"><span>&nbsp;S_full.matrix[8][3] = 1;S_full.matrix[8][4] = 1;S_full.matrix[8][5] = 1;S_full.matrix[8][6] = 1;</span></p><p class="c0"><span>&nbsp;S_full.matrix[9][3] = 1;S_full.matrix[9][4] = 1;S_full.matrix[9][5] = 1;</span></p><p class="c0"><span>&nbsp;S_full.matrix[10][2] = 1;S_full.matrix[10][3] = 1;S_full.matrix[10][4] = 1;S_full.matrix[10][5] = 1;</span></p><p class="c0"><span>&nbsp;S_full.matrix[11][2] = 1;S_full.matrix[11][3] = 1;S_full.matrix[10][4] = 1;S_full.matrix[12][2]</span></p><p class="c0"><span>&nbsp;S_full.matrix[12][5] = 1;S_full.matrix[12][4] = 1;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;S_full.matrix[9][8]=1;</span></p><p class="c0"><span>S_full.matrix[10][8]=1;</span></p><p class="c0"><span>S_full.matrix[11][8]=1;</span></p><p class="c0"><span>S_full.matrix[12][8]=1;</span></p><p class="c0"><span>S_full.matrix[13][8]=1;</span></p><p class="c0"><span>S_full.matrix[14][8]=1;</span></p><p class="c0"><span>S_full.matrix[15][8]=1;</span></p><p class="c0"><span>S_full.matrix[16][8]=1;</span></p><p class="c0"><span>S_full.matrix[17][8]=1;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>S_full.matrix[12][7]=1;</span></p><p class="c0"><span>S_full.matrix[13][7]=1;</span></p><p class="c0"><span>S_full.matrix[14][7]=1;</span></p><p class="c0"><span>S_full.matrix[15][7]=1;</span></p><p class="c0"><span>S_full.matrix[16][7]=1;</span></p><p class="c0"><span>S_full.matrix[17][7]=1;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int i = 0; i &lt; 500; i++){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbors[i].r = 0;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbors[i].c = 0;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbors[i].prev = NULL;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbors[i].next = NULL;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathArray-&gt;validPath = false;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathArray-&gt;pathLength = 0;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int i = 0; i &lt; 100; i ++){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathArray-&gt;waypoints[i].r = 0;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathArray-&gt;waypoints[i].c = 0;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathArray-&gt;waypoints[i].dist = 0;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp[i].r = 0;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp[i].c = 0;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp[i].dist = 0;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>}</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>void calcPath(path* pathArray, int goalRow, int goalCol, int startRow, int startCol)</span></p><p class="c0"><span>{</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initializeStuff(pathArray);</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(goalRow &gt; 0 &amp;&amp; goalCol &lt; S_full.rows){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(goalCol &gt; 0 &amp;&amp; goalRow &lt; S_full.rows){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(S_full.matrix[goalRow][goalCol] == 1) return;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else return;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else return;</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathArray-&gt;validPath = true;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wavefront(goalRow,goalCol,&amp;S_full);</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;findPath(&amp;S_full,startRow,startCol,pathArray,1,0);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//getCritical(pathArray);</span></p><p class="c0"><span>}</span></p><p class="c0 c1"><span class="c3"></span></p><p class="c0"><span class="c3">code robotArm.c</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>#pragma config(Motor, &nbsp;motorA, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Arm1, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tmotorNXT, PIDControl, encoder)</span></p><p class="c0"><span>#pragma config(Motor, &nbsp;motorB, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Arm2, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tmotorNXT, PIDControl, encoder)</span></p><p class="c0"><span>//*!!Code automatically generated by &#39;ROBOTC&#39; configuration wizard &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !!*//</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>const float L1 = 3.75;</span></p><p class="c0"><span>const float L2 = 2.5;</span></p><p class="c0"><span>const float degreesPerBox = 20;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>const float GR = 5;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>float check1 = 0;</span></p><p class="c0"><span>float check2 = 0;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>float getGoalDegree2(float x, float y, bool inFirstHalf){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float angle = acos(</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((x*x) + (y*y) - (L1*L1) - (L2*L2))/(2*L1*L2)</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!inFirstHalf){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;angle = -angle;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (angle + PI);</span></p><p class="c0"><span>}</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>float getGoalDegree1(float x, float y, float theta2){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float theta = theta2 - PI</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float alpha = 0;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(x == 0) alpha = (PI/2);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else alpha = atan(y/x);</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(x &lt; 0) alpha = alpha - PI;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return alpha - &nbsp;asin( (L2 * sin (theta)) / sqrt( (x * x) + (y*y)));</span></p><p class="c0"><span>}</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p><p class="c0"><span>void goToDegree(float r1,float r2){ //DON&#39;T FORGET TO RESET ENCODER VALUE TO BE ZERO AT THE BEGINNING</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int target1 = (r1-180) * GR;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int target2 = (r2 - 180) * GR;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;displayTextLine(1, &quot;arm1: %f&quot;, r1);</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;displayTextLine(2, &quot;arm2: %f&quot;, r2);</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int currVal1 = nMotorEncoder[Arm1];</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(currVal1 != target1){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int speed = ((target1 - currVal1) / abs(target1 - currVal1) ) * 20;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;motor[Arm1] = speed;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currVal1 = nMotorEncoder[Arm1];</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;motor[Arm1] = 0;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int currVal2 = nMotorEncoder[Arm2];</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(currVal2 != target2){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int speed = ((target2 - currVal2) / abs(target2 - currVal2) ) * 20;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;motor[Arm2] = speed;</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currVal2 = nMotorEncoder[Arm2];</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;motor[Arm2] = 0;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>int fromDegreesToBox(float radian){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int)(radian/degreesPerBox);</span></p><p class="c0"><span>}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>float fromBoxToDegrees(int box){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (((float)(box))*degreesPerBox);</span></p><p class="c0"><span>}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>void goToExactGoal(float goalR1, float goalR2){</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goToDegree(goalR1,goalR2);</span></p><p class="c0"><span>}</span></p><p class="c0 c1"><span></span></p><p class="c0"><span class="c3">code results.c</span></p><p class="c0 c1"><span class="c3"></span></p><p class="c0"><span>typedef struct thing</span></p><p class="c0"><span>{</span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int matrix[181][2];</span></p><p class="c0"><span>};</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>thing Meena;</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>void initializeThing(){</span></p><p class="c0"><span>Meena.matrix[0][0] = 3;Meena.matrix[0][1] = 177;</span></p><p class="c0"><span>Meena.matrix[1][0] = 3;Meena.matrix[1][1] = 175;</span></p><p class="c0"><span>Meena.matrix[2][0] = 4;Meena.matrix[2][1] = 172;</span></p><p class="c0"><span>Meena.matrix[3][0] = 4;Meena.matrix[3][1] = 170;</span></p><p class="c0"><span>Meena.matrix[4][0] = 5;Meena.matrix[4][1] = 167;</span></p><p class="c0"><span>Meena.matrix[5][0] = 5;Meena.matrix[5][1] = 165;</span></p><p class="c0"><span>Meena.matrix[6][0] = 6;Meena.matrix[6][1] = 162;</span></p><p class="c0"><span>Meena.matrix[7][0] = 6;Meena.matrix[7][1] = 160;</span></p><p class="c0"><span>Meena.matrix[8][0] = 7;Meena.matrix[8][1] = 157;</span></p><p class="c0"><span>Meena.matrix[9][0] = 7;Meena.matrix[9][1] = 155;</span></p><p class="c0"><span>Meena.matrix[10][0] = 8;Meena.matrix[10][1] = 152;</span></p><p class="c0"><span>Meena.matrix[11][0] = 9;Meena.matrix[11][1] = 149;</span></p><p class="c0"><span>Meena.matrix[12][0] = 9;Meena.matrix[12][1] = 147;</span></p><p class="c0"><span>Meena.matrix[13][0] = 10;Meena.matrix[13][1] = 144;</span></p><p class="c0"><span>Meena.matrix[14][0] = 10;Meena.matrix[14][1] = 142;</span></p><p class="c0"><span>Meena.matrix[15][0] = 11;Meena.matrix[15][1] = 139;</span></p><p class="c0"><span>Meena.matrix[16][0] = 11;Meena.matrix[16][1] = 137;</span></p><p class="c0"><span>Meena.matrix[17][0] = 12;Meena.matrix[17][1] = 134;</span></p><p class="c0"><span>Meena.matrix[18][0] = 13;Meena.matrix[18][1] = 131;</span></p><p class="c0"><span>Meena.matrix[19][0] = 13;Meena.matrix[19][1] = 129;</span></p><p class="c0"><span>Meena.matrix[20][0] = 14;Meena.matrix[20][1] = 126;</span></p><p class="c0"><span>Meena.matrix[21][0] = 15;Meena.matrix[21][1] = 123;</span></p><p class="c0"><span>Meena.matrix[22][0] = 16;Meena.matrix[22][1] = 120;</span></p><p class="c0"><span>Meena.matrix[23][0] = 16;Meena.matrix[23][1] = 118;</span></p><p class="c0"><span>Meena.matrix[24][0] = 17;Meena.matrix[24][1] = 115;</span></p><p class="c0"><span>Meena.matrix[25][0] = 18;Meena.matrix[25][1] = 112;</span></p><p class="c0"><span>Meena.matrix[26][0] = 19;Meena.matrix[26][1] = 109;</span></p><p class="c0"><span>Meena.matrix[27][0] = 20;Meena.matrix[27][1] = 106;</span></p><p class="c0"><span>Meena.matrix[28][0] = 21;Meena.matrix[28][1] = 103;</span></p><p class="c0"><span>Meena.matrix[29][0] = 22;Meena.matrix[29][1] = 100;</span></p><p class="c0"><span>Meena.matrix[30][0] = 23;Meena.matrix[30][1] = 97;</span></p><p class="c0"><span>Meena.matrix[31][0] = 24;Meena.matrix[31][1] = 94;</span></p><p class="c0"><span>Meena.matrix[32][0] = 25;Meena.matrix[32][1] = 91;</span></p><p class="c0"><span>Meena.matrix[33][0] = 26;Meena.matrix[33][1] = 88;</span></p><p class="c0"><span>Meena.matrix[34][0] = 28;Meena.matrix[34][1] = 84;</span></p><p class="c0"><span>Meena.matrix[35][0] = 30;Meena.matrix[35][1] = 80;</span></p><p class="c0"><span>Meena.matrix[36][0] = 32;Meena.matrix[36][1] = 76;</span></p><p class="c0"><span>Meena.matrix[37][0] = 34;Meena.matrix[37][1] = 72;</span></p><p class="c0"><span>Meena.matrix[38][0] = 37;Meena.matrix[38][1] = 67;</span></p><p class="c0"><span>Meena.matrix[39][0] = 41;Meena.matrix[39][1] = 61;</span></p><p class="c0"><span>Meena.matrix[40][0] = 0;Meena.matrix[40][1] = 0;</span></p><p class="c0"><span>Meena.matrix[41][0] = 0;Meena.matrix[41][1] = 0;</span></p><p class="c0"><span>Meena.matrix[42][0] = 0;Meena.matrix[42][1] = 0;</span></p><p class="c0"><span>Meena.matrix[43][0] = 0;Meena.matrix[43][1] = 0;</span></p><p class="c0"><span>Meena.matrix[44][0] = 0;Meena.matrix[44][1] = 0;</span></p><p class="c0"><span>Meena.matrix[45][0] = 0;Meena.matrix[45][1] = 0;</span></p><p class="c0"><span>Meena.matrix[46][0] = 0;Meena.matrix[46][1] = 0;</span></p><p class="c0"><span>Meena.matrix[47][0] = 0;Meena.matrix[47][1] = 0;</span></p><p class="c0"><span>Meena.matrix[48][0] = 0;Meena.matrix[48][1] = 0;</span></p><p class="c0"><span>Meena.matrix[49][0] = 0;Meena.matrix[49][1] = 0;</span></p><p class="c0"><span>Meena.matrix[50][0] = 0;Meena.matrix[50][1] = 0;</span></p><p class="c0"><span>Meena.matrix[51][0] = 0;Meena.matrix[51][1] = 0;</span></p><p class="c0"><span>Meena.matrix[52][0] = 0;Meena.matrix[52][1] = 0;</span></p><p class="c0"><span>Meena.matrix[53][0] = 0;Meena.matrix[53][1] = 0;</span></p><p class="c0"><span>Meena.matrix[54][0] = 221;Meena.matrix[54][1] = 225;</span></p><p class="c0"><span>Meena.matrix[55][0] = 219;Meena.matrix[55][1] = 228;</span></p><p class="c0"><span>Meena.matrix[56][0] = 217;Meena.matrix[56][1] = 230;</span></p><p class="c0"><span>Meena.matrix[57][0] = 214;Meena.matrix[57][1] = 232;</span></p><p class="c0"><span>Meena.matrix[58][0] = 212;Meena.matrix[58][1] = 233;</span></p><p class="c0"><span>Meena.matrix[59][0] = 210;Meena.matrix[59][1] = 234;</span></p><p class="c0"><span>Meena.matrix[60][0] = 207;Meena.matrix[60][1] = 235;</span></p><p class="c0"><span>Meena.matrix[61][0] = 205;Meena.matrix[61][1] = 236;</span></p><p class="c0"><span>Meena.matrix[62][0] = 202;Meena.matrix[62][1] = 236;</span></p><p class="c0"><span>Meena.matrix[63][0] = 200;Meena.matrix[63][1] = 237;</span></p><p class="c0"><span>Meena.matrix[64][0] = 197;Meena.matrix[64][1] = 237;</span></p><p class="c0"><span>Meena.matrix[65][0] = 194;Meena.matrix[65][1] = 237;</span></p><p class="c0"><span>Meena.matrix[66][0] = 192;Meena.matrix[66][1] = 237;</span></p><p class="c0"><span>Meena.matrix[67][0] = 189;Meena.matrix[67][1] = 237;</span></p><p class="c0"><span>Meena.matrix[68][0] = 186;Meena.matrix[68][1] = 237;</span></p><p class="c0"><span>Meena.matrix[69][0] = 183;Meena.matrix[69][1] = 237;</span></p><p class="c0"><span>Meena.matrix[70][0] = 181;Meena.matrix[70][1] = 237;</span></p><p class="c0"><span>Meena.matrix[71][0] = 178;Meena.matrix[71][1] = 237;</span></p><p class="c0"><span>Meena.matrix[72][0] = 175;Meena.matrix[72][1] = 237;</span></p><p class="c0"><span>Meena.matrix[73][0] = 172;Meena.matrix[73][1] = 237;</span></p><p class="c0"><span>Meena.matrix[74][0] = 169;Meena.matrix[74][1] = 236;</span></p><p class="c0"><span>Meena.matrix[75][0] = 167;Meena.matrix[75][1] = 236;</span></p><p class="c0"><span>Meena.matrix[76][0] = 164;Meena.matrix[76][1] = 235;</span></p><p class="c0"><span>Meena.matrix[77][0] = 161;Meena.matrix[77][1] = 235;</span></p><p class="c0"><span>Meena.matrix[78][0] = 159;Meena.matrix[78][1] = 234;</span></p><p class="c0"><span>Meena.matrix[79][0] = 156;Meena.matrix[79][1] = 234;</span></p><p class="c0"><span>Meena.matrix[80][0] = 154;Meena.matrix[80][1] = 233;</span></p><p class="c0"><span>Meena.matrix[81][0] = 151;Meena.matrix[81][1] = 233;</span></p><p class="c0"><span>Meena.matrix[82][0] = 149;Meena.matrix[82][1] = 232;</span></p><p class="c0"><span>Meena.matrix[83][0] = 147;Meena.matrix[83][1] = 231;</span></p><p class="c0"><span>Meena.matrix[84][0] = 144;Meena.matrix[84][1] = 230;</span></p><p class="c0"><span>Meena.matrix[85][0] = 142;Meena.matrix[85][1] = 230;</span></p><p class="c0"><span>Meena.matrix[86][0] = 140;Meena.matrix[86][1] = 229;</span></p><p class="c0"><span>Meena.matrix[87][0] = 138;Meena.matrix[87][1] = 228;</span></p><p class="c0"><span>Meena.matrix[88][0] = 137;Meena.matrix[88][1] = 227;</span></p><p class="c0"><span>Meena.matrix[89][0] = 136;Meena.matrix[89][1] = 226;</span></p><p class="c0"><span>Meena.matrix[90][0] = 135;Meena.matrix[90][1] = 225;</span></p><p class="c0"><span>Meena.matrix[91][0] = 134;Meena.matrix[91][1] = 224;</span></p><p class="c0"><span>Meena.matrix[92][0] = 133;Meena.matrix[92][1] = 223;</span></p><p class="c0"><span>Meena.matrix[93][0] = 132;Meena.matrix[93][1] = 222;</span></p><p class="c0"><span>Meena.matrix[94][0] = 131;Meena.matrix[94][1] = 220;</span></p><p class="c0"><span>Meena.matrix[95][0] = 130;Meena.matrix[95][1] = 218;</span></p><p class="c0"><span>Meena.matrix[96][0] = 130;Meena.matrix[96][1] = 216;</span></p><p class="c0"><span>Meena.matrix[97][0] = 129;Meena.matrix[97][1] = 213;</span></p><p class="c0"><span>Meena.matrix[98][0] = 128;Meena.matrix[98][1] = 211;</span></p><p class="c0"><span>Meena.matrix[99][0] = 127;Meena.matrix[99][1] = 209;</span></p><p class="c0"><span>Meena.matrix[100][0] = 127;Meena.matrix[100][1] = 206;</span></p><p class="c0"><span>Meena.matrix[101][0] = 126;Meena.matrix[101][1] = 204;</span></p><p class="c0"><span>Meena.matrix[102][0] = 126;Meena.matrix[102][1] = 201;</span></p><p class="c0"><span>Meena.matrix[103][0] = 125;Meena.matrix[103][1] = 199;</span></p><p class="c0"><span>Meena.matrix[104][0] = 125;Meena.matrix[104][1] = 196;</span></p><p class="c0"><span>Meena.matrix[105][0] = 124;Meena.matrix[105][1] = 193;</span></p><p class="c0"><span>Meena.matrix[106][0] = 124;Meena.matrix[106][1] = 191;</span></p><p class="c0"><span>Meena.matrix[107][0] = 123;Meena.matrix[107][1] = 188;</span></p><p class="c0"><span>Meena.matrix[108][0] = 123;Meena.matrix[108][1] = 185;</span></p><p class="c0"><span>Meena.matrix[109][0] = 123;Meena.matrix[109][1] = 182;</span></p><p class="c0"><span>Meena.matrix[110][0] = 123;Meena.matrix[110][1] = 179;</span></p><p class="c0"><span>Meena.matrix[111][0] = 123;Meena.matrix[111][1] = 177;</span></p><p class="c0"><span>Meena.matrix[112][0] = 123;Meena.matrix[112][1] = 174;</span></p><p class="c0"><span>Meena.matrix[113][0] = 123;Meena.matrix[113][1] = 171;</span></p><p class="c0"><span>Meena.matrix[114][0] = 123;Meena.matrix[114][1] = 168;</span></p><p class="c0"><span>Meena.matrix[115][0] = 123;Meena.matrix[115][1] = 166;</span></p><p class="c0"><span>Meena.matrix[116][0] = 123;Meena.matrix[116][1] = 163;</span></p><p class="c0"><span>Meena.matrix[117][0] = 123;Meena.matrix[117][1] = 160;</span></p><p class="c0"><span>Meena.matrix[118][0] = 124;Meena.matrix[118][1] = 158;</span></p><p class="c0"><span>Meena.matrix[119][0] = 124;Meena.matrix[119][1] = 155;</span></p><p class="c0"><span>Meena.matrix[120][0] = 125;Meena.matrix[120][1] = 153;</span></p><p class="c0"><span>Meena.matrix[121][0] = 126;Meena.matrix[121][1] = 150;</span></p><p class="c0"><span>Meena.matrix[122][0] = 127;Meena.matrix[122][1] = 148;</span></p><p class="c0"><span>Meena.matrix[123][0] = 128;Meena.matrix[123][1] = 146;</span></p><p class="c0"><span>Meena.matrix[124][0] = 130;Meena.matrix[124][1] = 143;</span></p><p class="c0"><span>Meena.matrix[125][0] = 132;Meena.matrix[125][1] = 141;</span></p><p class="c0"><span>Meena.matrix[126][0] = 135;Meena.matrix[126][1] = 139;</span></p><p class="c0"><span>Meena.matrix[127][0] = 0;Meena.matrix[127][1] = 0;</span></p><p class="c0"><span>Meena.matrix[128][0] = 0;Meena.matrix[128][1] = 0;</span></p><p class="c0"><span>Meena.matrix[129][0] = 0;Meena.matrix[129][1] = 0;</span></p><p class="c0"><span>Meena.matrix[130][0] = 0;Meena.matrix[130][1] = 0;</span></p><p class="c0"><span>Meena.matrix[131][0] = 0;Meena.matrix[131][1] = 0;</span></p><p class="c0"><span>Meena.matrix[132][0] = 0;Meena.matrix[132][1] = 0;</span></p><p class="c0"><span>Meena.matrix[133][0] = 0;Meena.matrix[133][1] = 0;</span></p><p class="c0"><span>Meena.matrix[134][0] = 0;Meena.matrix[134][1] = 0;</span></p><p class="c0"><span>Meena.matrix[135][0] = 0;Meena.matrix[135][1] = 0;</span></p><p class="c0"><span>Meena.matrix[136][0] = 0;Meena.matrix[136][1] = 0;</span></p><p class="c0"><span>Meena.matrix[137][0] = 0;Meena.matrix[137][1] = 0;</span></p><p class="c0"><span>Meena.matrix[138][0] = 0;Meena.matrix[138][1] = 0;</span></p><p class="c0"><span>Meena.matrix[139][0] = 0;Meena.matrix[139][1] = 0;</span></p><p class="c0"><span>Meena.matrix[140][0] = 0;Meena.matrix[140][1] = 0;</span></p><p class="c0"><span>Meena.matrix[141][0] = 299;Meena.matrix[141][1] = 319;</span></p><p class="c0"><span>Meena.matrix[142][0] = 293;Meena.matrix[142][1] = 323;</span></p><p class="c0"><span>Meena.matrix[143][0] = 288;Meena.matrix[143][1] = 326;</span></p><p class="c0"><span>Meena.matrix[144][0] = 284;Meena.matrix[144][1] = 328;</span></p><p class="c0"><span>Meena.matrix[145][0] = 280;Meena.matrix[145][1] = 330;</span></p><p class="c0"><span>Meena.matrix[146][0] = 276;Meena.matrix[146][1] = 332;</span></p><p class="c0"><span>Meena.matrix[147][0] = 272;Meena.matrix[147][1] = 334;</span></p><p class="c0"><span>Meena.matrix[148][0] = 269;Meena.matrix[148][1] = 335;</span></p><p class="c0"><span>Meena.matrix[149][0] = 266;Meena.matrix[149][1] = 336;</span></p><p class="c0"><span>Meena.matrix[150][0] = 263;Meena.matrix[150][1] = 337;</span></p><p class="c0"><span>Meena.matrix[151][0] = 260;Meena.matrix[151][1] = 338;</span></p><p class="c0"><span>Meena.matrix[152][0] = 257;Meena.matrix[152][1] = 339;</span></p><p class="c0"><span>Meena.matrix[153][0] = 254;Meena.matrix[153][1] = 340;</span></p><p class="c0"><span>Meena.matrix[154][0] = 251;Meena.matrix[154][1] = 341;</span></p><p class="c0"><span>Meena.matrix[155][0] = 248;Meena.matrix[155][1] = 342;</span></p><p class="c0"><span>Meena.matrix[156][0] = 245;Meena.matrix[156][1] = 343;</span></p><p class="c0"><span>Meena.matrix[157][0] = 242;Meena.matrix[157][1] = 344;</span></p><p class="c0"><span>Meena.matrix[158][0] = 240;Meena.matrix[158][1] = 344;</span></p><p class="c0"><span>Meena.matrix[159][0] = 237;Meena.matrix[159][1] = 345;</span></p><p class="c0"><span>Meena.matrix[160][0] = 234;Meena.matrix[160][1] = 346;</span></p><p class="c0"><span>Meena.matrix[161][0] = 231;Meena.matrix[161][1] = 347;</span></p><p class="c0"><span>Meena.matrix[162][0] = 229;Meena.matrix[162][1] = 347;</span></p><p class="c0"><span>Meena.matrix[163][0] = 226;Meena.matrix[163][1] = 348;</span></p><p class="c0"><span>Meena.matrix[164][0] = 223;Meena.matrix[164][1] = 349;</span></p><p class="c0"><span>Meena.matrix[165][0] = 221;Meena.matrix[165][1] = 349;</span></p><p class="c0"><span>Meena.matrix[166][0] = 218;Meena.matrix[166][1] = 350;</span></p><p class="c0"><span>Meena.matrix[167][0] = 216;Meena.matrix[167][1] = 350;</span></p><p class="c0"><span>Meena.matrix[168][0] = 213;Meena.matrix[168][1] = 351;</span></p><p class="c0"><span>Meena.matrix[169][0] = 211;Meena.matrix[169][1] = 351;</span></p><p class="c0"><span>Meena.matrix[170][0] = 208;Meena.matrix[170][1] = 352;</span></p><p class="c0"><span>Meena.matrix[171][0] = 205;Meena.matrix[171][1] = 353;</span></p><p class="c0"><span>Meena.matrix[172][0] = 203;Meena.matrix[172][1] = 353;</span></p><p class="c0"><span>Meena.matrix[173][0] = 200;Meena.matrix[173][1] = 354;</span></p><p class="c0"><span>Meena.matrix[174][0] = 198;Meena.matrix[174][1] = 354;</span></p><p class="c0"><span>Meena.matrix[175][0] = 195;Meena.matrix[175][1] = 355;</span></p><p class="c0"><span>Meena.matrix[176][0] = 193;Meena.matrix[176][1] = 355;</span></p><p class="c0"><span>Meena.matrix[177][0] = 190;Meena.matrix[177][1] = 356;</span></p><p class="c0"><span>Meena.matrix[178][0] = 188;Meena.matrix[178][1] = 356;</span></p><p class="c0"><span>Meena.matrix[179][0] = 185;Meena.matrix[179][1] = 357;</span></p><p class="c0"><span>Meena.matrix[180][0] = 183;Meena.matrix[180][1] = 357;</span></p><p class="c0"><span>}</span></p><p class="c0 c1"><span></span></p><p class="c0 c1"><span></span></p></body></html>