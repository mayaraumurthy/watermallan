#pragma config(Motor,  motorA,          Arm1,          tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          Arm2,          tmotorNXT, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const float L1 = 3.75;
const float L2 = 2.5;
const float degreesPerBox = 20

const float GR = 5;

float check1 = 0;
float check2 = 0;

float getGoalDegree2(float x, float y, bool inFirstHalf){
		float angle = acos(
		((x*x) + (y*y) - (L1*L1) - (L2*L2))/(2*L1*L2)
		);

		if(!inFirstHalf){
			angle = -angle;
		}
		return (angle + PI);
}


float getGoalDegree1(float x, float y, float theta2){
	float theta = theta2 - PI
	float alpha = 0;
	if(x == 0) alpha = (PI/2);
	else alpha = atan(y/x);

	if(x < 0) alpha = alpha - PI;

	return alpha -  asin( (L2 * sin (theta)) / sqrt( (x * x) + (y*y)));
}


void goToDegree(float r1,float r2){ //DON'T FORGET TO RESET ENCODER VALUE TO BE ZERO AT THE BEGINNING
	displayTextLine(1, "arm1: %f", nMotorEncoder[Arm1]);
	displayTextLine(2, "arm2: %f", nMotorEncoder[Arm2]);
	int target1 = r1 * GR;
	if(target1 == 0) target1 = 1;
	int target2 = (r2 - 180) * GR;
	if(target2 == 0) target2 = 1;


	nMotorEncoderTarget[Arm1]=target1;
	nMotorEncoderTarget[Arm2]=target2 ;

	motor[Arm1]=20;
	float allowedError=5;//*PI/180;
	while (nMotorRunState[Arm1] != runStateIdle){
		wait10Msec(1);
	}
	motor[Arm1]=0;;
	if(target2 =
	motor[Arm2]=20;
	while (nMotorRunState[Arm2] != runStateIdle){
		wait10Msec(1);
		displayTextLine(2, "arm2: %f", nMotorEncoder[Arm2]);
	}
	motor[Arm2]=0;
}

int fromDegreesToBox(float radian){
	return (int)(radian/degreesPerBox);
}

float fromBoxToDegrees(int box){
	return (((float)(box))*degreesPerBox);
}

void goToExactGoal(float goalR1, float goalR2){
	goToDegree(goalR1,goalR2);
}


task main{
	goToDegree(90, 90);
	goToDegree(0, 0);

	while(true){
		int x = 0;
	}
}
