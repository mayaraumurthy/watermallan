
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const float L1 = 3.75;
const float L2 = 2.5;
const float degreesPerBox = 20;

const float GR = 5;

float check1 = 0;
float check2 = 0;

float getGoalDegree2(float x, float y, bool inFirstHalf){
		float angle = acos(
		((x*x) + (y*y) - (L1*L1) - (L2*L2))/(2*L1*L2)
		);

		if(!inFirstHalf){
			angle = -angle;
		}
		return (angle + PI);
}


float getGoalDegree1(float x, float y, float theta2){
	float theta = theta2 - PI
	float alpha = 0;
	if(x == 0) alpha = (PI/2);
	else alpha = atan(y/x);

	if(x < 0) alpha = alpha - PI;

	return alpha -  asin( (L2 * sin (theta)) / sqrt( (x * x) + (y*y)));
}


void goToDegree(float r1,float r2){ //DON'T FORGET TO RESET ENCODER VALUE TO BE ZERO AT THE BEGINNING
	displayTextLine(1, "arm1: %f", nMotorEncoder[Arm1]);
	displayTextLine(2, "arm2: %f", nMotorEncoder[Arm2]);
	int target1 = r1 * GR;
	int target2 = (r2 - 180) * GR;


	int currVal1 = nMotorEncoder[Arm1];
	while(currVal1 != target1){
			int speed = ((target1 - currVal1) / abs(target1 - currVal1) ) * 20;
			motor[Arm1] = speed;
			currVal1 = nMotorEncoder[Arm1];
	}

	motor[Arm1] = 0;

	int currVal2 = nMotorEncoder[Arm2];
	while(currVal2 != target2){
			int speed = ((target2 - currVal2) / abs(target2 - currVal2) ) * 20;
			motor[Arm2] = speed;
			currVal2 = nMotorEncoder[Arm2];
	}

	motor[Arm2] = 0;
}

int fromDegreesToBox(float radian){
	return (int)(radian/degreesPerBox);
}

float fromBoxToDegrees(int box){
	return (((float)(box))*degreesPerBox);
}

void goToExactGoal(float goalR1, float goalR2){
	goToDegree(goalR1,goalR2);
}
