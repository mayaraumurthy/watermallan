#include "waveFrontDir2.c"
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*****************************************
 * Lab 3 : Starter code
 * Written by Kaushik Viswanathan
 *****************************************/
//hello
//Global variables - you will need to change some of these
float robot_X = 0.0, robot_Y = 0.0, robot_TH = 0.0;
int velocityUpdateInterval = 5;
int PIDUpdateInterval = 2;
int inputA[3] = {60, -30, -30};
int inputB[3] = {50, 30, -42};
//int inputA[3] = {60, 0, 0};
//int inputB[3] = {50, 0, 0};
const float radius = 28;
const float base = 132;

float accumL = 0;
float accumR = 0;

float r = 0;

float mOffsetX= -34;
float mOffsetY = 0;

float mPowerR = 0;
float mPowerL	 = 0;

path pathArray;
float goalRow = 3;
float goalCol = 6;
float startRow = 1;
float startCol = 1;
float goalx = 2.5;
float goaly = 5.5;
float startx = 0.5;
float starty = 0.5;


bool isEnd = false;

float waypointSteps = 1.25;

float convertToPos(float index){
	return ((index * 6) + 3)*25.4;
}




float smoothPos(float prevVali, float goalVali, float time){
		float prevVal = convertToPos(prevVali);
		float goalVal = convertToPos(goalVali);
		float diff = ((goalVal - prevVal) /waypointSteps) * time;
		return prevVal + diff;
}


void getDesiredPos(float t, float* desiredPos, int* flag){
	int prevStep = (int)(t / waypointSteps);
	int currStep = (int)(t / waypointSteps) + 1;

	float prevRow;
	float prevCol;

	float desiredRow;
	float desiredCol;

	prevRow = (float)pathArray.waypoints[(int)prevStep].r;
	prevCol = (float)pathArray.waypoints[(int)prevStep].c;

	if(prevRow == -1){
		isEnd = true;
		//(soundBeepBeep);
	}

	if(isEnd){
		prevRow = goalx;
		prevCol = goaly;
	}

	if(prevRow == goalx && prevCol == goaly){
		*flag = 1;
		/*desiredRow = goalRow + 0.5 * pathArray.dir[0];
		desiredCol = goalCol + 0.5 * pathArray.dir[1];
		prevRow = goalRow + 0.5 * pathArray.dir[0];
		prevCol = goalCol + 0.5 * pathArray.dir[1];*/

		desiredRow = goalx + 0.5 * pathArray.dir[0];
		desiredCol = goaly + 0.5 * pathArray.dir[1];
		prevRow = goalx + 0.5 * pathArray.dir[0];
		prevCol = goaly ;//+ 0.5 * pathArray.dir[1];


	}
	else{
		desiredRow = pathArray.waypoints[(int)currStep].r;
		desiredCol = pathArray.waypoints[(int)currStep].c;
	}

	/*if(desiredRow == -1){
		desiredRow = goalRow + 0.5 * pathArray.dir[0];
		desiredCol = goalCol + 0.5 * pathArray.dir[1];
	}*/


	desiredPos[0] = smoothPos(prevRow, desiredRow, t - (prevStep * waypointSteps));
	desiredPos[1] = smoothPos(prevCol, desiredCol, t - (prevStep * waypointSteps));

	displayTextLine(2, "X: %f", desiredPos[0]);
	displayTextLine(5, "Y: %f", desiredPos[1]);
	displayTextLine(6, "X: %f", desiredRow);
	displayTextLine(7, "Y: %f", desiredCol);



}

void desiredVelOmega(float theta,float lx,float ly, float* pd, float* pc,float* vw){


	float k=1;
	float xpVel=k*(pd[0]-pc[0]);
	float ypVel=k*(pd[1]-pc[1]);
	displayTextLine(0, "X: %f", xpVel);
	displayTextLine(1, "Y: %f", ypVel);
	float v=(cos(theta)-(sin(theta)*ly)/lx)*xpVel + (sin(theta)+cos(theta)*ly/lx)*ypVel;
	float w=-sin(theta)/lx*xpVel+cos(theta)/lx*ypVel;

	vw[0]=v;
	vw[1]=w;


}


void findWheelPower(float* vels, float* wheelVel){
	float vel = vels[0];
	float angVel = vels[1];
	float p = 0.15;
	if(angVel > (PI/6.0)){
		p = 0.15;
	}
	wheelVel[0] = p*(180/PI) * ((2*vel - base * angVel)/radius);
	wheelVel[1] = p*(180/PI) * ((2*vel + base*angVel)/radius);
}

void findCurrMPos(float x, float y, float theta, float* currMPos, int flag){
	if (flag == 1) {mOffsetX = mOffsetX;}
	currMPos[0] = mOffsetX * cos(theta) - mOffsetY * sin(theta) + x;
	currMPos[1] = mOffsetX * sin(theta) + mOffsetY * cos(theta) + y;
}



/*****************************************
 * Complete this function so that it
 * continuously updates the robot's position
 *****************************************/

 void adjustStartPos(float* prevX, float* prevY){
   (*prevX)=*prevX+mOffsetX;
   (*prevY)=*prevY-mOffsetY;
 }

 task dead_reckoning()
{

	float prevX = convertToPos(startx);
	float prevY = convertToPos(starty);
	adjustStartPos(&prevX,&prevY);

	float prevAngle = PI - 3 * PI / 4;

	int prevTicksR = 0;
	int prevTicksL = 0;

	int currTicksR =0;
	int currTicksL =0;

	float prevTime = 0;
	float currTime=0;

	float timeLapse;
	while(1)
	{
		//
		//Fill in code for numerical integration / position estimation here
		currTicksR = nMotorEncoder[motorRight];
		currTicksL = nMotorEncoder[motorLeft];

		currTime = (float)nPgmTime/1000;
		timeLapse = currTime - prevTime;
		prevTime = currTime;

		float ticksL = currTicksL - prevTicksL;
		float ticksR = currTicksR - prevTicksR;


		accumL += ticksL;
		accumR += ticksR;


		float velL=((float)(ticksL/timeLapse)) * radius*PI/180;
		float velR=((float)(ticksR/timeLapse)) * radius*PI/180;

		float vel = (velL + velR)/2;
		float angVel = (velR - velL)/base;


		float k00 = vel * cos(prevAngle);
		float k01 = vel * sin(prevAngle);
		float k02 = angVel;

		float k10 = vel * cos(((float)prevAngle) + ((float)(timeLapse/2))*k02);
		float k11 = vel * sin(((float)prevAngle) + ((float)(timeLapse/2))*k02);
		float k12 = angVel;

		float k20 = vel * cos(prevAngle + ((float)(timeLapse/2))*k12);
		float k21 = vel * sin(prevAngle + ((float)(timeLapse/2))*k12);
		float k22 = angVel;

		float k30 = vel * cos(prevAngle + ((float)(timeLapse))*k22);
		float k31 = vel * sin(prevAngle + ((float)(timeLapse))*k22);
		float k32 = angVel;


		prevX = prevX + ((float)timeLapse/6) * (k00+2*(k10+k20)+k30);
		prevY = prevY + ((float)timeLapse/6) * (k01+ 2*(k11+k21)+k31);
		prevAngle = prevAngle + ((float)timeLapse/6) * (k02+ 2*(k12+k22)+k32);

		prevTicksL = currTicksL;
		prevTicksR = currTicksR;

		robot_X = prevX;
		robot_Y = prevY;
		robot_TH = prevAngle;


	 	float desiredPos[2];
	 	int flag = 0;
	  getDesiredPos((float)nPgmTime/1000, desiredPos, &flag);
	  float currMPos[2];
	 	findCurrMPos(robot_X, robot_Y, robot_TH, currMPos, flag);
	 	float vels[2];
	 	desiredVelOmega(robot_TH, mOffsetX, mOffsetY, desiredPos, currMPos, vels);
	 	float wheelPows[2];
	 	findWheelPower(vels, wheelPows);

	 	mPowerL = wheelPows[0];
	 	mPowerR = wheelPows[1];

	 	displayTextLine(0, "X: %f", robot_X);
		displayTextLine(1, "Y: %f", robot_Y);
		displayTextLine(2, "t: %f", (float)((57.2958 * robot_TH) % 360));
	  displayTextLine(3, "r: %f", r);

		wait1Msec(velocityUpdateInterval);
	}
}
