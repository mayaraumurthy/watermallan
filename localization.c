#pragma config(Sensor, S2,     sonarSensor,    sensorSONAR)
#pragma config(Motor,  motorA,          motorRight,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          motorLeft,     tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


bool localized = false;
int end_loc = 0;
int record_prevprev = 0;
int num_till_goal = 100;
bool stop_lf = false;
int num_till_goal_copy = num_till_goal;


#include <DeadReckoningTests.c>
typedef struct data
{
	int obstacles[10];
	float sensorReadings[10];
	float probs[10];
	int size;
	float mmPerBlock;
	float cornerArray[10];

	int goalIndex;
} data;

void initProbArray(data* D){
	int i;
	for ( i=0;i<D->size;i++){
		D->probs[i]=1.0;
	}
}

///@returns the number of squares till the goal
int numSquaresTillGoal(data* D, int currIndex){

	if (currIndex> (D->goalIndex)){
		return ( D->size+(D->goalIndex) - currIndex);
		}else{
		return ((D->goalIndex)-currIndex);
	}

}

//Takes in to account corners  when sensing information about the environment
void multSensorByCornerArray(data* D,bool* turned){
	playSound(soundLowBuzz);
	for(int i = 0;i<D->size;i++){
		D->sensorReadings[i]=(D->sensorReadings[i])*(D->cornerArray[i]);
	}
	(*turned)=false;
}

//shift the probabilities when we move
void shiftProbs(data* D, bool shiftLeft){
	//copy probabilities to another array
	int i;

	if (shiftLeft){
		float firstProb=D->probs[0];
		for(i=0;i<((D->size)-1);i++){
			D->probs[i]=D->probs[i+1];
		}
		D->probs[(D->size)-1]=firstProb;
		}else{ //shift right
		float lastProb=D->probs[(D->size)-1];
		for(i=((D->size)-1);i>0;i--){
			D->probs[i]=D->probs[i-1];
		}
		D->probs[0]=lastProb;
	}
}

void normalize(float* array,int size){
	//find max
	int i;
	float max=-1.0;
	for(i=0;i<size;i++){
		if (array[i]>=max) max=array[i];
	}

	for(i=0;i<size;i++){
		array[i]=array[i]/max;
	}

}


void multProbsSensor(data* D){
	int i;
	for(i=0;i<((D->size));i++){
		D->probs[i]=(D->probs[i])*(D->sensorReadings[i]);
	}

}

//returns -1 if it hasn't found a location,
//and location in array otherwise
int foundLocation(data*D){
	int i;
	//it needs to know exactly one location
	int totalOnes=0;
	int oneLoc=-1;
	for (i=0;i< (D->size);i++){
		if ((D->probs[i])==1){
			totalOnes++;
			oneLoc=i;
		}
	}
	if (totalOnes==1){
		return oneLoc;
	}
	if(totalOnes==0){
		initProbArray(D);
		playSound(soundUpwardTones);

	}
	return -1;

}

void updateSensorReadings(data* D, bool sensedObstacle){
	int i;
	for(i=0;i<((D->size));i++){
		if (sensedObstacle){
			D->sensorReadings[i]=D->obstacles[i];
			}else{
			//put a one for every location without an obstacle

			D->sensorReadings[i]=(float)(((int)(D->obstacles[i]))^1);

		}
	}
}

//@returns true ifthere is an obstacle, else false
bool hasObstacle(){
	if(SensorValue[sonarSensor] <= 35){
		playSound(soundBeepBeep);
		return true;
	}
	return false;
}

//updates sensor readings, shifts probabilities, and detect corners
void makeUpdates(data* D, bool* turned){
	bool sensedObstacle=hasObstacle();
	updateSensorReadings(D,sensedObstacle);

		multSensorByCornerArray(D, turned);
	}

	shiftProbs(D,false);
	multProbsSensor(D);
}

bool shouldMakeUpdate(data* D,float* prevUpdateX,float* prevUpdateY,
float* prevprevUpdateX, float* prevprevUpdateY, bool* turned){
	//within a certain interval of where we want to s
	//we haven't sampled within that interval already

	int oldX=(int)(*prevUpdateX);
	int oldY=(int)(*prevUpdateY);
	int oldoldX = (int)(*prevprevUpdateX);
	int oldoldY = (int)(*prevprevUpdateY);
	int x=(int)robot_X;
	int y=(int)robot_Y;
	int mmPerBlock=(int)D->mmPerBlock;
	float diffX1;
	float diffX2;
	float diffY1;
	float diffY2;
	float tolerance = 25;

	if (((abs(x-oldX))>mmPerBlock) || ((abs(y-oldY))>mmPerBlock)){
		if (record_prevprev == 1) {
			diffX1 = abs(x - oldX);
			diffX2 = abs(oldX - oldoldX);
			diffY1 = abs(y - oldY);
			diffY2 = abs(oldY - oldoldY);

			float tempX = abs(diffX1 - diffX2);
			float tempDiffX = abs(tempX - (int)mmPerBlock);
			float tempY = abs(diffY1 - diffY2);
			float tempDiffY = abs(tempY - (int)mmPerBlock);


			if  ((tempDiffX <tolerance) || (tempDiffY <tolerance)) {
				//playSound(soundLowBuzz);
				*turned = true;
				}

			(*prevprevUpdateX)=(*prevUpdateX);
			(*prevprevUpdateY)=(*prevUpdateY);
			} else {
			record_prevprev = 1;
		}
		(*prevUpdateX)=robot_X;
		(*prevUpdateY)=robot_Y;

		return true;
		}else{
		return false;
	}
}

void convertInput(int obs, data* d) {
	int i;
	for (i = 0; i < 10; i++) {
		d->obstacles[i] = obs & 1;
		obs = obs >> 1;
	}
}

//initializes the obstacle array
void initializeStruct(data* D){

	D->size = 10;
	D->mmPerBlock = 145.4;
	D->goalIndex = 8;


	convertInput(685  ,D)

	initProbArray(D);
	D->cornerArray[0] = 1;
	D->cornerArray[1] = 0;
	D->cornerArray[2] = 1;
	D->cornerArray[3] = 0;
	D->cornerArray[4] = 0;
	D->cornerArray[5] = 1;
	D->cornerArray[6] = 0;
	D->cornerArray[7] = 1;
	D->cornerArray[8] = 0;
	D->cornerArray[9] = 0;

}


task local_main()
{
	float prevprevUpdateX=0;
	float prevprevUpdateY=0;
	float prevUpdateX=0;
	float prevUpdateY=0;
	bool turned=false;
	data D;
	initializeStruct(&D);
	makeUpdates(&D,&turned);
	startTask(dead_reckoning);

	end_loc = foundLocation(&D);

	while(end_loc == -1){

		if(shouldMakeUpdate(&D, &prevUpdateX, &prevUpdateY, &prevprevUpdateX, &prevprevUpdateY, &turned)){
			makeUpdates(&D, &turned);

		}

		end_loc = foundLocation(&D);
	}
	num_till_goal = numSquaresTillGoal(&D, end_loc);
	num_till_goal_copy = num_till_goal;

	playSound(soundDownwardTones);

	while(num_till_goal > 0){
		if(shouldMakeUpdate(&D, &prevUpdateX, &prevUpdateY, &prevprevUpdateX, &prevprevUpdateY, &turned)){
			num_till_goal = num_till_goal-1;
		}
	}
	stop_lf = true;

	while(true){
		int x = 1;
	}
	// team WAtermallan is the best at everything in das haus.
}
