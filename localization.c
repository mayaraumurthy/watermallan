#pragma config(Sensor, S2,     sonarSensor,    sensorSONAR)
#pragma config(Motor,  motorA,          motorRight,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          motorLeft,     tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//



bool localized = false;
int end_loc = 0;
int num_till_goal = 100;
bool stop_lf = false;
int num_till_goal_copy = num_till_goal;

#include <DeadReckoningTests.c>
typedef struct data
{
	int obstacles[10];
	float sensorReadings[10];
	float probs[10];
	int size;
	float mmPerBlock;
	float cornerArray[10];

	int goalIndex;
} data;

void initProbArray(data* D){
	int i;
	for ( i=0;i<D->size;i++){
		D->probs[i]=1.0;
	}
}

int numSquaresTillGoal(data* D, int currIndex){
	if (currIndex> (D->goalIndex)){
		return ( D->size+(D->goalIndex) - currIndex);
		}else{
		return ((D->goalIndex)-currIndex);
	}

}

void multSensorByCornerArray(data* D){
	for(int i;i<D->size;i++){
		D->sensorReadings[i]=(D->sensorReadings[i])*(D->cornerArray[i]);
	}
}

void shiftProbs(data* D, bool shiftLeft){
	//copy probabilities to another array
	int i;

	if (shiftLeft){
		float firstProb=D->probs[0];
		for(i=0;i<((D->size)-1);i++){
			D->probs[i]=D->probs[i+1];
		}
		D->probs[(D->size)-1]=firstProb;
	}else{ //shift right
		float lastProb=D->probs[(D->size)-1];
		for(i=((D->size)-1);i>0;i--){
			D->probs[i]=D->probs[i-1];
		}
		D->probs[0]=lastProb;
	}
}

void normalize(float* array,int size){
	//find max
	int i;
	float max=-1.0;
	for(i=0;i<size;i++){
		if (array[i]>=max) max=array[i];
	}

	for(i=0;i<size;i++){
		array[i]=array[i]/max;
	}

}


void multProbsSensor(data* D){
	int i;
	for(i=0;i<((D->size));i++){
		D->probs[i]=(D->probs[i])*(D->sensorReadings[i]);
	}
}

//returns -1 if it hasn't found a location,
//and location in array otherwise
int foundLocation(data*D){
	int i;
	//it needs to know exactly one location
	int totalOnes=0;
	int oneLoc=-1;
	for (i=0;i< (D->size);i++){
		if ((D->probs[i])==1){
			totalOnes++;
			oneLoc=i;
		}
	}
	if (totalOnes==1){
		return oneLoc;
	}
	if(totalOnes==0){
		initProbArray(D);
		playSound(soundUpwardTones);

	}
	return -1;

}

void updateSensorReadings(data* D, bool sensedObstacle){
	int i;
	for(i=0;i<((D->size));i++){
		if (sensedObstacle){
			D->sensorReadings[i]=D->obstacles[i];
		}else{
			//put a one for every location without an obstacle

			D->sensorReadings[i]=(float)(((int)(D->obstacles[i]))^1);

		}
	}
}

//Detect the things.
bool hasObstacle(){
	if(SensorValue[sonarSensor] <= 35){
		playSound(soundBeepBeep);
		return true;
	}
	return false;
}

void makeUpdates(data* D){
	bool sensedObstacle=hasObstacle();
	updateSensorReadings(D,sensedObstacle);
	shiftProbs(D,false);
	multProbsSensor(D);
}

//float x,float y, float prevUpdateX, float prevUpdateY
bool shouldMakeUpdate(data* D,float* prevUpdateX,float* prevUpdateY){
	//within a certain interval of where we want to s
	//we haven't sampled within that interval already

	int oldX=(int)(*prevUpdateX);
	int oldY=(int)(*prevUpdateY);
	int x=(int)robot_X;
	int y=(int)robot_Y;
	int mmPerBlock=(int)D->mmPerBlock;

	if (((abs(x-oldX))>mmPerBlock) || ((abs(y-oldY))>mmPerBlock)){
		(*prevUpdateX)=robot_X;
		(*prevUpdateY)=robot_Y;
		//playSound(soundBeepBeep);
		return true;
	}else{
		return false;
	}
}


void initializeStruct(data* D){

		D->size = 10;
		D->mmPerBlock = 145.4;
		D->goalIndex = 0;

		D->obstacles[0] = 0;
		D->obstacles[1] = 0;
		D->obstacles[2] = 0;
		D->obstacles[3]= 1;
		D->obstacles[4] = 1;
		D->obstacles[5] = 1;
		D->obstacles[6] = 1;
		D->obstacles[7] = 1;
		D->obstacles[8] = 0;
		D->obstacles[9] = 1;
		initProbArray(D);
    D->cornerArray[0] = 1;
    D->cornerArray[1] = 0;
    D->cornerArray[2] = 1;
    D->cornerArray[3] = 0;
    D->cornerArray[4] = 0;
    D->cornerArray[5] = 1;
    D->cornerArray[6] = 0;
    D->cornerArray[7] = 1;
    D->cornerArray[8] = 0;
    D->cornerArray[9] = 0;

}


task local_main()
{
	float prevUpdateX=0;
	float prevUpdateY=0;
	data D;
	initializeStruct(&D);
	makeUpdates(&D);
	startTask(dead_reckoning);

	end_loc = foundLocation(&D);
	displayTextLine(0, "%d %d %d %d %d", (int)D.probs[0], (int)D.probs[1], (int)D.probs[2], (int)D.probs[3], (int)D.probs[4]);
	displayTextLine(1, "%d %d %d %d %d", (int)D.probs[5], (int)D.probs[6], (int)D.probs[7], (int)D.probs[8], (int)D.probs[9]);
	while(end_loc == -1){
		//playSound(soundShortBlip);
		if(shouldMakeUpdate(&D, &prevUpdateX, &prevUpdateY)){
			makeUpdates(&D);
		displayTextLine(0, "%d %d %d %d %d", (int)D.probs[0], (int)D.probs[1], (int)D.probs[2], (int)D.probs[3], (int)D.probs[4]);
		displayTextLine(1, "%d %d %d %d %d", (int)D.probs[5], (int)D.probs[6], (int)D.probs[7], (int)D.probs[8], (int)D.probs[9]);
		}
		end_loc = foundLocation(&D);
	}
	num_till_goal = numSquaresTillGoal(&D, end_loc);
	num_till_goal_copy = num_till_goal;
	//localized = true;
	playSound(soundDownwardTones);

	while(num_till_goal > 0){
		if(shouldMakeUpdate(&D, &prevUpdateX, &prevUpdateY)){
			num_till_goal = num_till_goal-1;
		}
	}
	stop_lf = true;

		displayTextLine(0, "%d %d %d %d %d", (int)D.probs[0], (int)D.probs[1], (int)D.probs[2], (int)D.probs[3], (int)D.probs[4]);
		displayTextLine(1, "%d %d %d %d %d", (int)D.probs[5], (int)D.probs[6], (int)D.probs[7], (int)D.probs[8], (int)D.probs[9]);

	while(true){
		int x = 1;
	}
 // team WAtermallan is the best at everything in das haus.
}
