#pragma config(Sensor, S2,     sonarSensor,    sensorSONAR)
#pragma config(Motor,  motorA,          motorRight,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          motorLeft,     tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include <DeadReckoningTests.c>
typedef struct data
{
	int obstacles[10];
	float sensorReadings[10];
	float probs[10];
	int size;
	float mmPerBlock;
} data;

void shiftProbs(data* D, bool shiftLeft){
	//copy probabilities to another array
	int i;

	if (shiftLeft){
		float firstProb=D->probs[0];
		for(i=0;i<((D->size));i++){
			D->probs[i]=D->probs[i+1];
		}
		D->probs[(D->size)-1]=firstProb;
	}else{ //shift right
		float lastProb=D->probs[(D->size)-1];
		for(i=((D->size)-1);i>=0;i--){
			D->probs[i]=D->probs[i-1];
		}
		D->probs[0]=lastProb;
	}
}

void normalize(float* array,int size){
	//find max
	int i;
	float max=-1.0;
	for(i=0;i<size;i++){
		if (array[i]>=max) max=array[i];
	}

	for(i=0;i<size;i++){
		array[i]=array[i]/max;
	}

}


void multProbsSensor(data* D){
	int i;
	for(i=0;i<((D->size));i++){
		D->probs[i]=(D->probs[i])*(D->sensorReadings[i]);
	}
}

//returns -1 if it hasn't found a location,
//and location in array otherwise
int foundLocation(data*D){
	int i;
	//it needs to know exactly one location
	int totalOnes=0;
	int oneLoc=-1;
	for (i=0;i< (D->size);i++){
		if ((D->probs[i])==1){
			totalOnes++;
			oneLoc=i;
		}
	}
	if (totalOnes==1){
		return oneLoc;
	}else{
		return -1;
	}
}

void updateSensorReadings(data* D, bool sensedObstacle){
	int i;
	for(i=0;i<((D->size));i++){
		if (sensedObstacle){
			D->sensorReadings[i]=D->obstacles[i];
		}else{
			//put a one for every location without an obstacle

			D->sensorReadings[i]=(float)(((int)(D->obstacles[i]))^1);

		}
	}
}

//Detect the things.
bool hasObstacle(){
	if(SensorValue[sonarSensor] >= 20){
		playSound(soundBeepBeep);
		return true;
	}
	return false;
}

void makeUpdates(data* D){
	bool sensedObstacle=hasObstacle();
	updateSensorReadings(D,sensedObstacle);
	shiftProbs(D,true);
	multProbsSensor(D);
}

//float x,float y, float prevUpdateX, float prevUpdateY
bool shouldMakeUpdate(data* D,int prevUpdateX,int prevUpdateY){
	//within a certain interval of where we want to s
	//we haven't sampled within that interval already
	int x=(int)robot_X;
	int y=(int)robot_Y;
	int mmPerBlock=(int)D->mmPerBlock;
	float minInterval=10.0;
	if ((( (int)x%(mmPerBlock)) < minInterval) ||((y%(mmPerBlock)) < minInterval)){
		if ((abs(x-prevUpdateX)>(mmPerBlock)) || (abs(y-prevUpdateY)>(mmPerBlock))){
			return true;
		}else{
 			return false;
		}
	}else{
		return false;
	}
}


task main()
{
	int prevUpdateX=0;
	int prevUpdateY=0;
	data D;
	makeUpdates(&D);
	startTask(dead_reckoning);
	while(!foundLocation(&D)){
		if(shouldMakeUpdate(&D, prevUpdateX, prevUpdateY)){
			makeUpdates(&D);
			prevUpdateX = robot_X;
			prevUpdateY = robot_Y;
		}
	}


 // team WAtermallan is the best at everything in das haus.
}
